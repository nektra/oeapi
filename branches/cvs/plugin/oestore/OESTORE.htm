<!DOCTYPE HTML PUBLIC -//W3C//DTD HTML 4.0 Transitional//EN>
<html><head><title>OESTORE</title><meta name=GENERATOR content=tlb2h></head>
<body>
<h1>OESTORE</h2>
<h2>Content:</h2>
<h3>Coclasses:</h3>
<table>
<tr><td>OEMessage</td><td><i>OEMessage coclass</i></td></tr>
<tr><td>OEFolder</td><td><i>OEFolder coclass</i></td></tr>
<tr><td>OEFolderManager</td><td><i>OEFolderManager coclass</i></td></tr>
</table>
<h3>Interfaces:</h3>
<table>
<tr><td><a href="#IOEFolder">IOEFolder</a></td><td><i>IOEFolder interface</i></td></tr>
<tr><td><a href="#IOEFolderEvents">IOEFolderEvents</a></td><td><i>IOEFolderEvents Interface</i></td></tr>
<tr><td><a href="#IOEFolderManager">IOEFolderManager</a></td><td><i>IOEFolderManager interface</i></td></tr>
<tr><td><a href="#IOEFolderManagerEvents">IOEFolderManagerEvents</a></td><td><i>IOEFolderManagerEvents Interface</i></td></tr>
<tr><td><a href="#IOEMessage">IOEMessage</a></td><td><i>IOEMessage interface</i></td></tr>
</table>
<h2>Details:</h2><hr>
<h3><a name=IOEFolder>IOEFolder</a></h3>
<p>IOEFolder interface</p>
<p>long GetID();

<br>
<i>Get the folder's id.</i></p>
<p>com_ptr&lt;<a href="#IOEFolder">IOEFolder</a>&gt; GetFirstChild();

<br>
<i>Get first child folder. Returns NULL if there is no child folder.</i></p>
<p>com_ptr&lt;<a href="#IOEFolder">IOEFolder</a>&gt; GetNextChild();

<br>
<i>Get next child folder. Returns NULL when finishes.</i></p>
<p>com_ptr&lt;<a href="#IOEMessage">IOEMessage</a>&gt; GetFirstMessage();

<br>
<i>Get the folder's first message. Returns NULL if no message is found.</i></p>
<p>com_ptr&lt;<a href="#IOEMessage">IOEMessage</a>&gt; GetNextMessage();

<br>
<i>Get next message of the folder. Returns NULL when finishes.</i></p>
<p>com_ptr&lt;<a href="#IOEMessage">IOEMessage</a>&gt; GetMessage(long msgId);

<br>
<i>Get a folder's message by id. If the id does not match it returns NULL.</i></p>
<p>com_ptr&lt;<a href="#IOEMessage">IOEMessage</a>&gt; CreateMessage(const bstr_t&amp; msgSource, long status = 0);

<br>
<i>Create a new message in the folder. msgSource must contain all the source of the message.</i></p>
<p>long DeleteMessage(long msgId, long permanent);

<br>
<i>Move the message to the 'Deleted items' folder, by id. If permanent is TRUE the message is permanently deleted, instead of just moved to the 'Deleted items' folder.</i></p>
<p>bstr_t Name();

<br>
<i>Get the folder's name.</i></p>
<p>long IsNull();

<br>
<i>Verifies if it's a valid folder.</i></p>
<p>long MarkAsRead(long msgId);

<br>
<i>Marks the message as read.</i></p>
<p>long MarkAsUnread(long msgId);

<br>
<i>Marks the message as unread.</i></p>
<p>long IsInbox();

<br>
<i>Returns TRUE if it is the special folder Inbox.</i></p>
<p>long IsOutbox();

<br>
<i>Returns TRUE if it is the special folder Outbox.</i></p>
<p>long IsSent();

<br>
<i>Returns TRUE if it is the special folder Sent items.</i></p>
<p>long IsDeleted();

<br>
<i>Returns TRUE if it is the special folder Deleted items.</i></p>
<p>long IsDraft();

<br>
<i>Returns TRUE if it is the special folder Drafts.</i></p>
<p>long Rename(const bstr_t&amp; newName);

<br>
<i>Renames the folder. Returns TRUE on success.</i></p>
<p>long Move(long newParentId);

<br>
<i>Moves the folder. Returns TRUE on success.</i></p>
<p>long Delete();

<br>
<i>Deletes the folder. If the function returns TRUE the folder is no longer valid.</i></p>
<p>long CreateFolder(const bstr_t&amp; Name);

<br>
<i>Creates a folder. If the function fails it returns -1. Otherwise, it returns the folderId of the new folder.</i></p>
<p>long GetSubFolderCount();

<br>
<i>Gets the number of sub folders of the folder.</i></p>
<p>long GetUnreadCount();

<br>
<i>Gets the number of unread messages in the folder.</i></p>
<p>long GetMessageCount();

<br>
<i>Gets the number of messages in the folder.</i></p>
<hr>
<h3><a name=IOEFolderEvents>IOEFolderEvents</a></h3>
<p>IOEFolderEvents Interface</p>
<p>void OnNewMessage(long msgId);

<br>
<i>Event triggered when a message arrives to this folder.</i></p>
<p>void OnMessageDeleted(long msgId);

<br>
<i>Event triggered when a message of this folder is deleted.</i></p>
<p>void OnDeletion();

<br>
<i>Event triggered when the folder is deleted.</i></p>
<p>void OnMessageUnreadChange(long msgId, long unread);

<br>
<i>Event triggered when a message changes its unread state.</i></p>
<hr>
<h3><a name=IOEFolderManager>IOEFolderManager</a></h3>
<p>IOEFolderManager interface</p>
<p>void ActivateGlobalNotification();

<br>
<i>Activate the IOEFolderManagerEvents::OnNewMessage notification. You need to activate it explicitly because the activation takes some time.</i></p>
<p>com_ptr&lt;<a href="#IOEFolder">IOEFolder</a>&gt; GetInboxFolder();

<br>
<i>Gets the special folder Inbox.</i></p>
<p>com_ptr&lt;<a href="#IOEFolder">IOEFolder</a>&gt; GetOutboxFolder();

<br>
<i>Gets the special folder Outbox.</i></p>
<p>com_ptr&lt;<a href="#IOEFolder">IOEFolder</a>&gt; GetSentFolder();

<br>
<i>Gets the special folder Sent items.</i></p>
<p>com_ptr&lt;<a href="#IOEFolder">IOEFolder</a>&gt; GetDeletedFolder();

<br>
<i>Gets the special folder Deleted items.</i></p>
<p>com_ptr&lt;<a href="#IOEFolder">IOEFolder</a>&gt; GetDraftFolder();

<br>
<i>Gets the special folder Drafts.</i></p>
<p>com_ptr&lt;<a href="#IOEFolder">IOEFolder</a>&gt; GetFolder(long folderId);

<br>
<i>Get the folder using the id.</i></p>
<p>com_ptr&lt;<a href="#IOEFolder">IOEFolder</a>&gt; GetFirstFolder();

<br>
<i>Reset the internal OEFolder iterator. Using GetNextFolder the iterator browses all the folder hierarchy.</i></p>
<p>com_ptr&lt;<a href="#IOEFolder">IOEFolder</a>&gt; GetNextFolder();

<br>
<i>Get next folder. This function returns the first child folder of the previous folder if any, the sibling folder if any, or the parent. If the previous was the last folder, it returns NULL.</i></p>
<p>com_ptr&lt;<a href="#IOEFolder">IOEFolder</a>&gt; GetCurrentFolder();

<br>
<i>Get the current folder of the iterator. The last folder retrieved with GetFirstFolder or GetNextFolder.</i></p>
<p>long RenameFolder(long folderId, const bstr_t&amp; newName);

<br>
<i>Renames the folder.</i></p>
<p>long MoveFolder(long folderId, long newParentId);

<br>
<i>Moves the folder.</i></p>
<p>long DeleteFolder(long folderId);

<br>
<i>Deletes the specified folder. If the function returns TRUE the folderId is no longer valid.</i></p>
<p>long CreateFolder(long parentFolderId, const bstr_t&amp; Name);

<br>
<i>Creates a folder. If the function fails it returns -1. Otherwise, returns the folderId of the new folder.</i></p>
<p>long CopyMessage(long srcFolderId, long destFolderId, long msgId);

<br>
<i>Copies a message from srcFolderId to destFolderId.</i></p>
<p>long MoveMessage(long srcFolderId, long destFolderId, long msgId);

<br>
<i>Moves a message from srcFolderId to destFolderId.</i></p>
<hr>
<h3><a name=IOEFolderManagerEvents>IOEFolderManagerEvents</a></h3>
<p>IOEFolderManagerEvents Interface</p>
<p>void OnFolderCreated(long folderId);

<br>
<i>Event triggered when a folder is created.</i></p>
<p>void OnFolderDeleted(long folderId);

<br>
<i>Event triggered when a folder is deleted.</i></p>
<p>void OnFolderRenamed(long folderId);

<br>
<i>Event triggered when a folder is renamed.</i></p>
<p>void OnFolderMoved(long folderId);

<br>
<i>Event triggered when a folder is moved.</i></p>
<p>void OnFolderUnreadChanged(long folderId);

<br>
<i>Event triggered when a message from a folder changes its read flag.</i></p>
<p>void OnNewMessage(long folderId, long newMsgId);

<br>
<i>Event triggered when a new message is stored in a folder. This is a global event and can be used to know when a message is created in any folder.</i></p>
<hr>
<h3><a name=IOEMessage>IOEMessage</a></h3>
<p>IOEMessage interface</p>
<p>long GetID();

<br>
<i>Get the id.</i></p>
<p>long GetFolderID();

<br>
<i>Get the folder id.</i></p>
<p>bstr_t GetSubject();

<br>
<i>Get the subject.</i></p>
<p>bstr_t GetNormalSubject();

<br>
<i>Get the normalized subject.</i></p>
<p>bstr_t GetDisplayTo();

<br>
<i>Get the string that is displayed as to.</i></p>
<p>bstr_t GetDisplayFrom();

<br>
<i>Get the string that is displayed as from.</i></p>
<p>long GetState();

<br>
<i>Get the message's state flags. See OEAPIMSGSTATE for the state list.</i></p>
<p>void SetState(long state);

<br>
<i>Set the state flags. See OEAPIMSGSTATE for the state list. Only useful when a message is cloned, the new message can change state. Messages stored cannot change their state.</i></p>
<p>long MarkAsRead();

<br>
<i>Mark as read.</i></p>
<p>long MarkAsUnread();

<br>
<i>Mark as unread.</i></p>
<p>long Delete(long permanent);

<br>
<i>The message is moved to the 'Deleted items' folder. If permanent is TRUE the message is permanently deleted instead of moved to the 'Deleted items' folder.</i></p>
<p>long GetSourceLength();

<br>
<i>Get the entire message length.</i></p>
<p>bstr_t GetAllSource();

<br>
<i>Get all the source of the message. The message could be long, so this function could take a lot of time.</i></p>
<p>bstr_t GetSource(long maxBytesToRead);

<br>
<i>Get the first (in the first call) maxBytesToRead (if possible) of the message. Next calls to this function read next parts of the message. It returns an empty string when finished.</i></p>
<p>bstr_t GetHeader();

<br>
<i>Get the header of the message.</i></p>
<p>long GetHeaderLength();

<br>
<i>Get the length of the header of the message.</i></p>
<p>bstr_t GetAllBody();

<br>
<i>Get the entire body of the message. The message could be long, so this function could take a lot of time.</i></p>
<p>bstr_t GetBody(long maxBytesToRead);

<br>
<i>Get the first (in the first call) maxBytesToRead (if possible). Next calls to this function read next parts of the message. It returns an empty string when finished.</i></p>
<p>long GetBodyLength();

<br>
<i>Get the length of the body.</i></p>
<p>void GetContentReset();

<br>
<i>After calling this function GetBody and GetSource functions starts again from the beginning.</i></p>
<p>long HasNormalPriority();

<br>
<i>Returns true if the message has normal priority.</i></p>
<p>long HasLowPriority();

<br>
<i>Returns true if the message has low priority.</i></p>
<p>long HasHighPriority();

<br>
<i>Returns true if the message has high priority.</i></p>
<p>long GetHTMLBody();

<br>
<i>Get the first HTML body handle (if any) of the message, or 0 if the message has no HTML body. If the message is multi-part this function is useless.</i></p>
<p>long GetPlainBody();

<br>
<i>Get the first text (plain) body handle (if any) of the message or 0. If the message is multi-part this function is useless.</i></p>
<p>long GetBodyHandle(long prevBodyHandle, enum <a href=#tagOEAPIBODYLOCATION>tagOEAPIBODYLOCATION</a> bodyLoc);

<br>
<i>Get body handle specifying the location. If it is not found, returns 0.</i></p>
<p>long InsertBody(long bodyHandle, enum <a href=#tagOEAPIBODYLOCATION>tagOEAPIBODYLOCATION</a> bodyLoc);

<br>
<i>Taking bodyHandle as reference, inserts a new body using bodyLoc as the relation between the new body and bodyHandle. Returns 0 on error.</i></p>
<p>long DeleteBody(long bodyHandle, enum <a href=#tagOEAPIBODYDELFLAGS>tagOEAPIBODYDELFLAGS</a> flags);

<br>
<i>Delete a body. Returns TRUE on success.</i></p>
<p>long IsBodyContentType(long bodyHandle, const bstr_t&amp; priContentType, const bstr_t&amp; secContentType);

<br>
<i>Returns TRUE if the body is of the specified content type.</i></p>
<p>bstr_t GetBodyPrimaryContentType(long bodyHandle);

<br>
<i>Returns the primary content type of the body handle.</i></p>
<p>bstr_t GetBodySecondaryContentType(long bodyHandle);

<br>
<i>Returns the secondary content type of the body handle.</i></p>
<p>bstr_t GetBodyDisplayName(long bodyHandle);

<br>
<i>Get the display name of the body.</i></p>
<p>bstr_t GetBodyText(long bodyHandle);

<br>
<i>Get the text of the specified body handle.</i></p>
<p>long SetBodyText(long bodyHandle, const bstr_t&amp; bodyText, const bstr_t&amp; priContentType, const bstr_t&amp; secContentType);

<br>
<i>Set the text of the specified body handle. The type of the text must be specified, if you do not want to change it, send empty strings in both parameters and the type will remain unchanged.</i></p>
<p>long SaveBodyToFile(long bodyHandle, const bstr_t&amp; path, long useDefaultName);

<br>
<i>Save the specified body in a file.</i></p>
<p>long SetBodyFromFile(long bodyHandle, const bstr_t&amp; filename, const bstr_t&amp; priContentType, const bstr_t&amp; secContentType);

<br>
<i>Set the body content from the specified file. This function is useful if you want to add an attachment.</i></p>
<p>long IsBodyAttachment(long bodyHandle);

<br>
<i>Returns TRUE if the specified body is an attachment.</i></p>
<p>bstr_t GetFirstBodyProp(long bodyHandle, long&amp; propId);

<br>
<i>Get the text of the first property of the body. If the property does not exist propId is -1. Otherwise, contains property id.</i></p>
<p>bstr_t GetNextBodyProp(long&amp; propId);

<br>
<i>Get the text of the next property of the body. If the property does not exist propId is -1. Otherwise, contains property id.</i></p>
<p>bstr_t GetBodyProp(long bodyHandle, enum <a href=#tagOEAPIMIMEPROPID>tagOEAPIMIMEPROPID</a> propId, long&amp; exist);

<br>
<i>Gets the text of the specified property. If the property does not exists it returns 0 (False). propId is a long value and can be the value obtained using GetFirstBodyProp / GetNextBodyProp.</i></p>
<p>long SetBodyProp(long bodyHandle, enum <a href=#tagOEAPIMIMEPROPID>tagOEAPIMIMEPROPID</a> propId, const bstr_t&amp; propText);

<br>
<i>Sets the value of the property, specifying the property by id. Returns TRUE on success. propId is a long value and can be the value obtained using GetFirstBodyProp / GetNextBodyProp.</i></p>
<p>long SetBodyPropByName(long bodyHandle, const bstr_t&amp; propName, const bstr_t&amp; propText);

<br>
<i>Sets the value of the property, specifying the property by name. Returns TRUE on success.</i></p>
<p>bstr_t GetBodyPropByName(long bodyHandle, const bstr_t&amp; propName, long&amp; exist);

<br>
<i>Gets the value of the property, specifying the property by name. If the property does not exist, returns 0 (False).</i></p>
<p>long DeleteBodyProp(long bodyHandle, enum <a href=#tagOEAPIMIMEPROPID>tagOEAPIMIMEPROPID</a> propId);

<br>
<i>Remove a property specifying the id. Returns TRUE on success. propId is a long value and can be obtained using GetFirstBodyProp / GetNextBodyProp.</i></p>
<p>long DeleteBodyPropByName(long bodyHandle, const bstr_t&amp; propName);

<br>
<i>Remove a property specifying the name. Returns TRUE on success.</i></p>
<p>com_ptr&lt;<a href="#IOEMessage">IOEMessage</a>&gt; Clone(long folderId);

<br>
<i>Create a copy of the message in the specified folder. Only those functions that manipulate bodies and SetState can be used before you call Commit because the message does not have an id yet.</i></p>
<p>long Commit();

<br>
<i>Commit changes made in the bodies (properties and content). If you do not call this function after modifying bodies, the changes will not be saved.</i></p>
<p>long Send();

<br>
<i>The message is committed (all the changes made are saved) and sent using the default account of current user. Returns TRUE on success.</i></p>
<p>long GetFirstAttachment();

<br>
<i>Get the first attachment of the message. Returns 0 if the message does not have attachments.</i></p>
<p>long GetNextAttachment();

<br>
<i>Get next attachment of the message. Returns 0 if the message does not have attachments.</i></p>
<p>bstr_t GetFilename(long bodyHandle);

<br>
<i>Get the filename prop (equivalent to: GetBodyProp(bodyHandle, OE_PID_PAR_FILENAME, exist, filename).</i></p>
<p>long AttachFile(const bstr_t&amp; filename);

<br>
<i>Add an attachment to the message. Returns the new body handle or 0 on error.</i></p>
<p>void SetFolderID(long folderId);

<br>
<i>Set the new message's folder id.</i></p>
<p>long SaveAsFile(const bstr_t&amp; filename);

<br>
<i>Save message source to the specified filename.</i></p>
<p>void SetReadOnly(long readOnly);

<br>
<i>Set the message to be opened as read-only.</i></p>
<p>long IsReadOnly();

<br>
<i>Check if the message was set to be opened as read-only by the SetReadOnly() method.</i></p>
<p>unsigned long GetFlags();

<br>
<i>Gets the flags which describe the message composition.</i></p>
</body></html>