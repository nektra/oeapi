// OEstaff.h: different hacked OE functions, interfaces, and thunks
//
//////////////////////////////////////////////////////////////////////

#if !defined(_OESTAFF_H__INCLUDED_)
#define _OESTAFF_H__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "msoeapi.h"
#include "mimeole.h"

#include "iptr.h"

/*
	All essensies, declared or defined here have been gotten by analysis of MSOE.DLL using debut symbols available on msdl.microsoft.com

    To get the messages of OE we can use this way:
    
    - hook one or more methods of IMessageList. Then we automatically get the access directly to internal list, so, it is not necessary to hold the "reflection" model.
    
    	1. From the same address space and apartment - get the IMessageList using CoCreateInstance.
    	2. Get the TVM.
    	3. Save the addresses of original Addref() (and Release()).
    	4. Rewrite these addresses in TVM by our own functions-wrappers.
    	5. Free IMessageList.
    	
    The wrappers will trace the timelife of the object, and also keep the weak reference to the current used copy ("this") of IMessageList for further usage by another methods. Then they calls the oritinal saved functions, so, the interface still work as before.
    
    Getting the notifications about new messages (the working one!)
    
    - make a window and subscribe it to the notifications of IStoreNamespace. The research have shown, that this message will be fired as the the very first one when something happens. Then, when we receive a message, we can subscribe our sinker to the IStoreFolder notifications exactly in the handleeventer of the first notifications (namespace-level). And after that we immediately will take the notify about what exactly happened with which message in the folder. So, it is not necessary to hold as a maximum 15 notifications, but this is "dynamic" subscribing. Just process WM_NEWMSGS. It works! Know-how!
    
    Modification of the fields of a ready message.

	1. Get the IMimeMessage (for example, using OpenMessage).
	2. IMimeMessage::SetBodyProp(HBODY_ROOT,"x_name_of_header",0,&variant("value_of_header"));
	3. IMimeMessage::Commit(COMMIT_REUSESTORAGE);
		 

*/

// {233A9692-667E-11D1-9DFB-006097D50408}
DEFINE_GUID(CLSID_MessageList, 0x233A9692, 0x667E, 0x11D1, 0x9D, 0xFB, 0x0, 0x60, 0x97, 0xD5, 0x04, 0x08);

// {DE89B950-A597-11D1-9E46-006097D50408}
//DEFINE_GUID(IID_IMessageList, 0xDE89B950, 0xA597, 0x11D1, 0x9E, 0x46, 0x0, 0x60, 0x97, 0xD5, 0x04, 0x08);

// {101A8FB9-F1B9-11d1-9A56-00C04FA309D4}
DEFINE_GUID(CLSID_MessageStore, 0x101A8FB9, 0xF1B9, 0x11d1, 0x9A, 0x56, 0x0, 0xC0, 0x4F, 0xA3, 0x09, 0xD4);

// {101A8FB9-F1B9-11d1-9A56-00C04FA309D4}
DEFINE_GUID(CLSID_MessageStoreWMail, 0x101A8FB9, 0xF1B9, 0x11d1, 0x9A, 0x56, 0x0, 0xC0, 0x4F, 0xA3, 0x09, 0xD4);

// {E883FC75-EC08-11D1-9A53-00C04FA309D4}
DEFINE_GUID(IID_IMessageStore, 0xE883FC75, 0xEC08, 0x11D1, 0x9A, 0x53, 0x0, 0xC0, 0x4F, 0xA3, 0x09, 0xD4);

// {569BA773-508C-469B-8B21-CBCCBCB7BCD2}
DEFINE_GUID(IID_IMessageStoreWMail, 0x569BA773, 0x508C, 0x469B, 0x8B, 0x21, 0xCB, 0xCC, 0xBC, 0xB7, 0xBC, 0xD2);

// {B4B796AA-EC1C-11D1-9A54-00C04FA309D4}
DEFINE_GUID(IID_IMessageTable, 0xB4B796AA, 0xEC1C, 0x11d1, 0x9A, 0x54, 0x0, 0xc0, 0x4f, 0xA3, 0x09, 0xD4);

// {CFAD2437-EC54-11D1-9A54-00C04FA309D4}
DEFINE_GUID(IID_IStoreCallback, 0xCFAD2437, 0xEC54, 0x11d1, 0x9A, 0x54, 0x0, 0xc0, 0x4f, 0xA3, 0x09, 0xD4);

// {279644D0-0C73-11D2-AF3A-00C04FA31B90}
DEFINE_GUID(_CMDSETID_OutlookExpress,0x279644D0, 0x0C73, 0x11D2, 0xAF, 0x3A, 0x0, 0xC0, 0x4F, 0xA3, 0x1B, 0x90);

// {8551C145-0C39-11D2-9A6A-00C04FA309D4}
DEFINE_GUID(IID_IEnumerateFolders,0x8551C145, 0x0C39, 0x11D2, 0x9A, 0x6A, 0x0, 0xC0, 0x4F, 0xA3, 0x09, 0xD4);

// {5E8A5022-AC7C-11D1-9A16-00C04FA309D4};
DEFINE_GUID(IID_IDatabaseNotify,0x5E8A5022, 0xAC7C, 0x11D1, 0x9A, 0x16, 0x0, 0xC0, 0x4F, 0xA3, 0x09, 0xD4);

// {E883FC76-EC08-11D1-9A53-00C04FA309D4};
DEFINE_GUID(IID_IMessageFolder,0xE883FC76, 0xEC08,0x11D1, 0x9A, 0x53, 0x0, 0xC0, 0x4F, 0xA3, 0x09, 0xD4);

typedef DWORD MESSAGEID__, MESSAGEID;
typedef unsigned long FOLDERID__, FOLDERID;


// Some fields just for aligning, the meaning of them still unknown.
typedef struct tagMESSAGEINFO
{
	DWORD dwReserved;
	DWORD field_4;
	DWORD field_8;
	MESSAGEID dwMessageId;
	DWORD dwARF;
	FILETIME ftSent;
	DWORD field_1C;
	LPSTR DBFileAddrss;
	DWORD field_24;
	LPSTR pszNormalSubject;
	FILETIME ftSaved;
	LPSTR szRFCMessageID;
	LPSTR pszSubject;
	DWORD field_3C;
	DWORD dw_needonline;
	DWORD hdr_xref;
	LPSTR szAccount;
	LPSTR pszDisplayFrom;
	LPSTR pszSender;
	WORD wLanguage;
	WORD wPriority;
	DWORD cbMessage;
	FILETIME ftReceived;
	LPSTR pszDisplayTo;
	LPSTR pszEmailTo;
	DWORD total_currentparts;
	DWORD att_UIDL;
	DWORD field_74;
	DWORD content_type_id;
	DWORD forward_to;
	LPSTR pszAthenaAccountName;
	LPSTR szServerName;
	DWORD field_88;
	DWORD StmOffsetTableSize;
	LPVOID StmOffsetTableBinary;
	DWORD field_94;
	DWORD field_98;
	DWORD field_9c;
	DWORD field_A0;
	DWORD field_A4;
	DWORD field_A8;
	DWORD field_Ac;
	DWORD field_B0;
	DWORD field_B4;
} MESSAGEINFO, __RPC_FAR *LPMESSAGEINFO;

typedef struct tagMESSAGEINFOWMAIL
{
	DWORD field_0;
	DWORD field_4;
	DWORD field_8;
	DWORD field_c;
	MESSAGEID dwMessageId;
	DWORD field_14;
	DWORD field_18;
	DWORD field_1c;
	DWORD dwARF;
	DWORD field_24;
	DWORD field_28;
	DWORD field_2c;
	FILETIME ftSent;
	DWORD field_38;
	DWORD field_3c;
	DWORD field_40;
	LPSTR wzNormalSubject; // 44
	FILETIME ftSaved; // 48
	LPSTR szRFCMessageID; // 50
	LPWSTR wzSubject; // 54
	DWORD field_54; // 58
	DWORD field_58; // 5c
	DWORD field_5c; // 60
	LPSTR szAccount; // 64
	LPWSTR wzDisplayFrom;  // 68
	LPSTR szSender; // 6c
	WORD wLanguage; // 70
	WORD wPriority; // 74
	DWORD cbMessage; //78
	FILETIME ftReceived; // 7c
	LPWSTR wzDisplayTo; // 84
	LPSTR szEmailTo; // 88
	DWORD field_8c;
	DWORD field_90;
	DWORD field_94;
	DWORD field_98;
	DWORD field_9c;
	LPWSTR wzAccountName; // a0
	LPSTR szAccountGUID; // a4
	DWORD field_a8;
	DWORD field_ac;
	DWORD field_b0;
	DWORD field_b4;
	DWORD field_b8;
	DWORD field_bc;
	DWORD field_c0;
	DWORD field_c4;
	DWORD field_c8;
	DWORD field_cc;
	DWORD field_d0;
	DWORD field_d4;
	DWORD field_d8;
	DWORD field_dc;
	DWORD field_e0;
	DWORD field_e4;
	DWORD field_e8;
	DWORD field_ec;
	DWORD field_f0;
	DWORD field_f4;
	DWORD field_f8;
	DWORD field_fc;
	DWORD field_100;
	DWORD field_104;
	DWORD field_108;
} MESSAGEINFOWMAIL, __RPC_FAR *LPMESSAGEINFOWMAIL;

typedef struct tagFOLDERINFO
{
	DWORD field_0;
	DWORD field_4;
	FOLDERID__ dw_folderid;
	FOLDERID__ dw_parentfolderid;
	LPSTR sz_foldername;
	LPSTR sz_filename;
	LPSTR sz_accountname;
	LPSTR sz_storename;
	DWORD field_20;
	DWORD dwflags; // 10h - has_children. 1h - subscribed, 8 - server
	DWORD cMessage;
	DWORD num_unread;
	DWORD field_30;
	DWORD field_34;
	DWORD field_38;
	DWORD field_3C;
	BYTE specialFolder; // - 1 = tagSPECIALFOLDER
	BYTE type; // mail = 1 (IMAP) / non-mail = 0 (newsgroups) / offline(2) / online(0) / local = 3 (Local folders)
	BYTE field_42;
	BYTE field_43;
	DWORD field_44;
	DWORD field_48;
	DWORD field_4C;
	DWORD field_50;
	DWORD field_54;
	DWORD field_58;
	DWORD field_5C;
	DWORD field_60;
	DWORD unread_news;
	DWORD field_68;
	DWORD field_6C;
	DWORD field_70;
	DWORD field_74;
//	DWORD field_78;
//	DWORD bit_3;
} FOLDERINFO, __RPC_FAR *LPFOLDERINFO;


typedef struct tagFOLDERINFOWMAIL
{
	DWORD field_0;
	DWORD field_4;
	FOLDERID__ dw_folderid;
	DWORD field_c;
	FOLDERID__ dw_parentfolderid; // 10
	DWORD field_14;
	LPSTR sz_foldername; // 18
	LPSTR sz_filename; // 1c
	LPSTR sz_accountname; // 20
	LPSTR sz_storename; // 24
	DWORD field_28; // 28
	DWORD field_2c; // 2c
	DWORD dwflags; // 30 10h - has_children. 1h - subscribed, 8 - server
	DWORD cMessage; // 34
	DWORD num_unread; // 38
	DWORD field_3c; // 3c
	DWORD field_40; // 40
	DWORD field_44; // 44
	DWORD field_48; // 48
	BYTE specialFolder; // 4c - 1 = tagSPECIALFOLDER
	BYTE type; // 4d mail(1)/non-mail(0); offline(2)/online(0).
	BYTE field_4e; // 4e
	BYTE field_4f; // 4f
	DWORD field_50; // 50
	DWORD field_54; // 54
	DWORD field_58; // 58
	DWORD field_5c; // 5c
	DWORD field_60; // 60
	DWORD field_64; // 64
	DWORD field_68; // 68
	DWORD field_6c; // 6c
	DWORD unread_news; // 70
	DWORD field_74; // 74
	DWORD field_78; // 78
	DWORD field_7c; // 7c
	DWORD field_80; // 80
	DWORD field_84; // 84
	DWORD field_88; // 88
	DWORD field_8c; // 8c
	DWORD field_90; // 90
	DWORD field_94; // 94
	DWORD field_98; // 98
	DWORD field_9c; // 9c
	DWORD field_a0; // a0
} FOLDERINFOWMAIL, __RPC_FAR *LPFOLDERINFOWMAIL;


typedef struct tagADJUSTFLAGS
{
	DWORD flARFReset;
	DWORD flARFSet;
} ADJUSTFLAGS, __RPC_FAR *LPADJUSTFLAGS;

//typedef struct tagMESSAGEINFO __RPC_FAR *LPMESSAGEINFO;

typedef struct tagORDINALLIST
{
	DWORD field00;
	DWORD field01;
	DWORD field02;
	DWORD field03;
	DWORD field04;
	DWORD field05;
	DWORD field06;
	DWORD field07;
	DWORD field08;
	DWORD field09;
	DWORD field0a;
	DWORD field0b;
	DWORD field0c;
	DWORD field0d;
	DWORD field0e;
	DWORD field0f;

} ORDINALLIST, __RPC_FAR *LPORDINALLIST;

typedef enum tagTRANSACTIONTYPE
{
	tr_insertrecord = 0,
	tr_updaterecord = 1,
	tr_deleterecord = 2,
	tr_rebuildindex = 3,
	tr_deleteindex = 4,
	tr_basecompacted = 5

} TRANSACTIONTYPE, __RPC_FAR *LPTRANSACTIONTYPE;

struct tagFINDINFO;
struct tagGETCOUNTTYPE;
struct tagAPPLYCHILDRENTYPE;
struct tagMARK_TYPE;
struct tagFOLDERSORTINFO;
struct tagGETNEXTTYPE;
struct tagROWMESSAGETYPE;
struct tagRELATIVEROWTYPE;

struct tagFINDNEXTFLAGS;
struct tagFOLDER_OPTIONS;
struct tagSTOREOPERATIONINFO;
struct tagSTOREERROR;

interface IListSelector;
interface IOperationCancel;
interface IMessageServer;
interface IMessageTableNotify;
interface INETSERVER;
enum tagIXPTYPE;

typedef enum tagSTOREOPERATIONTYPE
{
	op_SynchronizeFolder = 2,
	op_GetMessageA = 3,
	op_PutMessage = 4,
	op_CopyMessages = 5,
	op_SynchronizeStore = 6,
	op_CreateFolder = 7,
	op_DeleteMessages = 9,
	op_SetMessageFlags = 10,
	op_MoveFolder = 11,
	op_DeleteFolder = 12,
	op_RenameFolder = 13,
	op_SubscribeToFolder = 14,
	op_GetFolderCounts = 15,
	op_GetNewGroups = 17,
	op_GetWatchedInfo = 20,
	op_GetAdBarUrl = 22,
	op_GetMinPollingInterval = 23

} STOREOPERATIONTYPE, *LPSTOREOPERATIONTYPE;


interface IStoreCallback : public IUnknown
{

// _IID_IStoreCallback  = {CFAD2437-EC54-11D1-9A54-00C04FA309D4};
	virtual HRESULT STDMETHODCALLTYPE OnBegin(tagSTOREOPERATIONTYPE,tagSTOREOPERATIONINFO *,IOperationCancel *);
	virtual HRESULT STDMETHODCALLTYPE OnProgress(tagSTOREOPERATIONTYPE,ULONG,ULONG,char const *);
	virtual HRESULT STDMETHODCALLTYPE OnTimeout(INETSERVER *,ULONG *,tagIXPTYPE);
	virtual HRESULT STDMETHODCALLTYPE CanConnect(char const *,ULONG);
	virtual HRESULT STDMETHODCALLTYPE OnLogonPrompt(INETSERVER *,tagIXPTYPE);
	virtual HRESULT STDMETHODCALLTYPE OnComplete(tagSTOREOPERATIONTYPE,long,tagSTOREOPERATIONINFO *,tagSTOREERROR *);
	virtual HRESULT STDMETHODCALLTYPE OnPrompt(long,char const *,char const *,UINT,int *);
	virtual HRESULT STDMETHODCALLTYPE GetParentWindow(ULONG,HWND__ * *);
};
//
////////////////////////////////////////////////////////////////////////////
//interface IMessageTable : public IUnknown
//{
//
//	virtual HRESULT STDMETHODCALLTYPE Initialize(FOLDERID__ *,IMessageServer *,int,IStoreCallback *);
//	virtual HRESULT STDMETHODCALLTYPE StartFind(tagFINDINFO *,IStoreCallback *);
//	virtual HRESULT STDMETHODCALLTYPE SetOwner(IStoreCallback *);
//	virtual HRESULT STDMETHODCALLTYPE Close(void);
//	virtual HRESULT STDMETHODCALLTYPE Synchronize(ULONG,ULONG,IStoreCallback *);
//	virtual HRESULT STDMETHODCALLTYPE GetCount(tagGETCOUNTTYPE,ULONG *);
//	virtual HRESULT STDMETHODCALLTYPE GetRow(ULONG,tagMESSAGEINFO * *); // get messageinfo for current row. It is necessary to be freed after use!!
//	virtual HRESULT STDMETHODCALLTYPE ReleaseRow(tagMESSAGEINFO *); // free the messageinfo
//	virtual HRESULT STDMETHODCALLTYPE GetIndentLevel(ULONG,ULONG *);
//	virtual HRESULT STDMETHODCALLTYPE Mark(ULONG *,ULONG,tagAPPLYCHILDRENTYPE,tagMARK_TYPE,IStoreCallback *);
//	virtual HRESULT STDMETHODCALLTYPE GetSortInfo(tagFOLDERSORTINFO *);
//	virtual HRESULT STDMETHODCALLTYPE OnSynchronizeComplete(void);
//	virtual HRESULT STDMETHODCALLTYPE SetSortInfo(tagFOLDERSORTINFO *,IStoreCallback *);
//	virtual HRESULT STDMETHODCALLTYPE GetLanguage(ULONG,ULONG *);
//	virtual HRESULT STDMETHODCALLTYPE SetLanguage(ULONG,ULONG *,ULONG);
//	virtual HRESULT STDMETHODCALLTYPE GetNextRow(ULONG,tagGETNEXTTYPE,tagROWMESSAGETYPE,ULONG,ULONG *);
//	virtual HRESULT STDMETHODCALLTYPE GetRelativeRow(ULONG,tagRELATIVEROWTYPE,ULONG *);
//	virtual HRESULT STDMETHODCALLTYPE GetRowState(ULONG,ULONG,ULONG *);
//	virtual HRESULT STDMETHODCALLTYPE GetSelectionState(ULONG,ULONG *,ULONG,int,ULONG *);
//	virtual HRESULT STDMETHODCALLTYPE Expand(ULONG);
//	virtual HRESULT STDMETHODCALLTYPE Collapse(ULONG);
//	virtual HRESULT STDMETHODCALLTYPE OpenMessage(ULONG,ULONG,IMimeMessage * *,IStoreCallback *);
//	virtual HRESULT STDMETHODCALLTYPE GetRowMessageId(ULONG,MESSAGEID__ * *);
//	virtual HRESULT STDMETHODCALLTYPE GetRowIndex(MESSAGEID__ *,ULONG *);
//	virtual HRESULT STDMETHODCALLTYPE DeleteRows(ULONG arg1,ULONG szsource,ULONG *source,int with_threads,IStoreCallback *arg5);
//	/*
//	DeleteRows работает так:
//	GetMessageIdList(with_threads==0?1:0,szsource,source,varIDlist);
//	internalMessageFolder->DeleteMessages(arg1,tagMESSAGEIDLIST *varIDlist, 0,IStoreCallback * arg5);
//
//	CStoreFolder::delete_messages (msglist, reserved, progress) работает так:
//
//	IMessageFolder->DeleteMessages(4,msglist,0,(IStoreCallback*)this);
//	*/
//	virtual HRESULT STDMETHODCALLTYPE CopyRows(FOLDERID__ target,ULONG dwFlags,ULONG rowssz,ULONG *rows,tagADJUSTFLAGS *tagadj,IStoreCallback *storeclbck);
//	/*
//	OpenFolder (target,&idfolder);
//	GetMessageIdList(0,rowssz,rows,&pMsgIdList);
//	internalfolder::CopyMessages(idfolder,dwFlags,pMsgIdList,tagadj,0,storeclbck);
//
//	CStore::copymove works this way::
//	HRESULT CopyMoveMessages(IStoreFolder *pSource, IStoreFolder *pDest, LPMESSAGEIDLIST pMsgIdList,
//		DWORD dwFlags, DWORD dwFlagsRemove, IProgressNotify *pProgress );
//
//	IStoreFolder -> CStoreFolder::GetMessageFolder -> IMessageFolder (iSource, iDest)
//
//	dwFlagsRemove is being converted by internal DwConvertMSGtoARF by this table:
//	
//	MSG_DELETED		(0x0001)		or	0x00000080
//	MSG_UNREAD		(0x0002)		xor	0x00000080
//	MSG_SUBMITTED		(0x0004)		or	0x00010080
//	MSG_UNSENT		(0x0008)		or	0x00000088
//	MSG_RECEIVED		(0x0010)		or	0x00020080
//	MSG_NEWSMSG		(0x0020)		or	0x00000880
//	MSG_NOSECUI		(0x0040)		or	0x00000480
//	MSG_VOICEMAIL		(0x0080)		or	0x00008080
//	MSG_REPLIED		(0x0100)		or	0x00080080
//	MSG_FORWARDED		(0x0200)		or	0x00100080
//	MSG_RCPTSENT		(0x0400)		or	0x00040080
//	MSG_FLAGGED		(0x0800)		or	0x000000A0
//	
//	ARF 0x00000100 - marked for downloading;
//		0x00400000 - marked by "glasses";
//		0x00800000 - marked by "anti-glasses";
//		0x00004000 - contains attachment(s);
//		0x00000001 - downloaded (i.e., accessible locally, without the internet).
//
//	for example, MSG_RCPTSENT | MSG_VOICEMAIL | MSG_UNREAD станет 0x00040080 | 0x00008080 ^ 0x00000080 = 0x00048000.
//
//	Another scheme: 
//
//	&4?		|10000
//	&8?		|8
//	&10?	|20000
//	&20?	|800
//	&40?	|400
//	&80?	|8000
//	&100?	|80000
//	&200?	|1000000
//	&400?	|40000
//	&800?	|20
//
//	(!=0) && (!&2)?	|80
//
//  The constant ARF) come to function 
//
//	iSource->CopyMessages (iDest,dwFlags,pMsgIdList,&arf,0,(IStoreCallback*)this)
//
//	*/
//	virtual HRESULT STDMETHODCALLTYPE RegisterNotify(ULONG,IMessageTableNotify *);
//	virtual HRESULT STDMETHODCALLTYPE UnregisterNotify(IMessageTableNotify *);
//	virtual HRESULT STDMETHODCALLTYPE FindNextRow(ULONG,char const *,tagFINDNEXTFLAGS,int,ULONG *,int *);
//	virtual HRESULT STDMETHODCALLTYPE GetRowFolderId(ULONG,FOLDERID__*);
//	virtual HRESULT STDMETHODCALLTYPE GetMessageIdList(int only_one,ULONG szsource,ULONG * source,MESSAGEIDLIST * result);
//	virtual HRESULT STDMETHODCALLTYPE ConnectionRelease(void);
//	virtual HRESULT STDMETHODCALLTYPE IsChild(unsigned long,unsigned long);
//	virtual HRESULT STDMETHODCALLTYPE GetAdBarUrl(struct IStoreCallback *);
//};
//

//////////////////////////////////////////////////////////////////////////
//pseudocode 
//HRESULT IMessageFolder::OpenMessage(MESSAGEID messageid, 
//	ULONG a_ulong, IMimeMessage** ppIMimeMessage, IStoreCallBack* pIStoreCallback)
;
/*{
	MESSAGEINFO tmpinfo = {0};
	HRESULT hr;
	PROPVARIANT varr = {0};
	varr.vt = VT_LPSTR;
	
	if (*ppIMimeMessage != NULL)
		return E_INVALIDARG;
		
	iptrIMessageStore = this_get_global_imsgstore;
	
	for (;;)
	{
		tmpinfo.dwMessageId = messageid;
		hr =iptrIMessageStore->FindRecord(0,-1,&tmpinfo,0);
		if (FAILED(hr))
			break;
			
		if (hr != 0x000C0321)
			return 0x800C013E;
			
		if (tmpinfo.dwARF & 2)
			return 0x800C0071h;
			
		if (tmpinfo.DBFileAddrss == NULL)
			return 0x800C006C; // msg_need_online
			
		IMimeMessage * pMessage = NULL;
		hr = MimeOleCreateMessage(NULL, &pMessage);
		
		if (FAILED(hr))
			break;
			
		//enum  tagACCESSTYPE,unsigned long,struct IStream * *
		iptrIStream tmpstream;
		hr = iptrIMessageStore->OpenStream(100,tmpinfo.field_20,&tmpstream);
		
		if (FAILED(hr))
			break;
			
		if (tmpinfo.StmOffsetTableSize > 0)
		{
			CByteStream xx(tmpinfo.StmOffsetTableBinary,tmpinfo.StmOffsetTableSize);
			pMessage->LoadOffsetTable((IStream*)&xx);
			xx.AcquireBytes(&tmpinfo.StmOffsetTableSize,&tmpinfo.StmOffsetTableBinary,1);
		}
		
		hr = pMessage->Load(tmpstream);
		
		if (FAILED(hr))
			break;
		
		if (!(a_ulong & 1))	
		{
			if (FAILED(HandleSecurity(0,pMessage))
				break;
		}
		
		if (tmpinfo.server)
		{
			varr.value = tmpinfo.server;
			pMessage->SetProp(PIDTOSTR(PID_ATT_SERVER),0,&varr);
		}
		
		if (tmpinfo.account)
		{
			varr.value = tmpinfo.account;
			pMessage->SetProp(PIDTOSTR(PID_ATT_ACCOUNT),0,&varr);
		}
		
		if (tmpinfo.athena_account_name)
		{
			varr.value = tmpinfo.athena_account_name;
			pMessage->SetProp("att:athena-account-name",0,&varr);
		} 
		else if (tmpinfo.Account)
		{	
			iptrImnAccount account;
			g_pAcctMan->FindAccount(AP_RAS_BACKUP_CONNECTOID,tmpinfo.Account,&account);
			
			char accname[0x100];
			account->GetPropSz(AP_ACCOUNT_NAME,accname,0x100);
			
			varr.value = accname;
			pMessage->SetProp("att:athena-account-name",0,&varr);
		}
		
		if (tmpinfo.att_UIDL)
		{
			varr.value = tmpinfo.att_UIDL;
			pMessage->SetProp(PIDTOSTR(PID_ATT_UIDL),0,&varr);
		}
		
		if (tmpinfo.forward_to)
		{
			varr.value = tmpinfo.forward_to;
			pMessage->SetProp(PIDTOSTR(PID_ATT_UIDL),0,&varr);
		}
		
		if (tmpinfo.dwARF & 8) //MSG_UNSENT
		{
			varr.value = "1";
			pMessage->SetProp(PIDTOSTR(PID_HDR_XUNSENT),0,&varr);
		}
		
		if (FAILED(FixupMessageCharset(pMessage,tmpinfo.wLanguage))
			break;
			
		MimeOleClearDirtyTree(pMessage);
		*ppIMimeMessage = pMessage;
		pMessage->AddRef();
		
	break;}
	
	iptrIMessageStore->FreeRecord(&tmpinfo);
	
	if (pMessage)
		pMessage->Release();
		
	if (tmpstream)
		tmpstream->Release();	
	
}
*/
;
//////////////////////////////////////////////////////////////////////////
// pseudocode
// HRESULT IStoreFolder::CreateStream(HBATCHLOCK hBatchLock,
//		DWORD dwReserved,IStream **ppStream,LPMESSAGEID pdwMessageId)
;
/*
{
	if (FAILED(IMessageFolder_ptr->GenerateID(pdwMessageId))
		return E_INVALIDARG;
		
	if (FAILED(IMessageFolder_ptr->CreateStream(&dwReserved))
		return S_FALSE;
		
	if (FAILED(IMessageFolder_ptr->OpenStream(0xC8,dwReserved,ppStream)
		return S_FALSE;
}
*/
;
//////////////////////////////////////////////////////////////////////////
// pseudocode
// HRESULT IStoreFolder::CommitStream(HBATCHLOCK hBatchLock,
//		DWORD dwFlags,DWORD dwMsgFlags,IStream *pStream,MESSAGEID dwMessageId,
//		IMimeMessage *pMessage)
;
/*
{
	DWORD ARF = DwConvertMSGtoARF(dwMsgFlags);
	if (!pStream)
		return E_INVALIDARG;
		
	if (dwMessageId == MESSAGEID_INVALID)
		return E_INVALIDARG;
		
	IDatabaseStream* idbstr = NULL;
	pStream->QueryInterface(&IID_IDatabaseStream,(void**)&idbstr);
	
	if (dwFlags & COMMITSTREAM_REVERT)
	{
		ULONG faddress;
		idbstr->GetFileAddress(&faddress);
		IMessageFolder_ptr->DeleteStream(faddress);
		return S_OK;
	}
	
	if (FAILED(IMessageFolder_ptr->ChangeStreamLock(idbstr,100)))
		return E_FAIL;
		
	if (!pMessage)
	{
		if (FAILED(MimeOleCreateMessage(0,&pMessage)))
			return E_FAIL;
			
		if (FAILED(HrRewindStream(pStream)))
			return E_FAIL;
			
		pMessage->Load(pStream);	
	} 
	else
		pMessage->AddRef();
	
	DWORD flags;
	pMessage->GetFlags(&flags);
	if (flags & IMF_VOICEMAIL)
		ARF |= MSG_VOICEMAIL;
		
	IMessageFolder_ptr->SaveMessage(&dwMessageId,0,ARF,idbstr,pMessage,(IStoreCallback*)this);
}
*/
;
//////////////////////////////////////////////////////////////////////////
// pseudocode
// HRESULT IStoreFolder::SaveMessage(REFIID riid,LPVOID pvObject,DWORD dwMsgFlags,
//		LPMESSAGEID pdwMessageId)
;
/*
{
	if (riid != _IID_IStream && riid != _IID_IMimeMessage)
		return E_INVALIDARG;
		
	_locker lock(this);
	
	iptrIStream spIStream, spIStream2;
	DWORD MessageID;
	iptrIMimeMessage spIMimeMessage;
	if (SUCCEEDED(CreateStream(0,0,&spIStream,&MessageID)))
	{
		for (;;)
		{
			if (riid == _IID_IStream)
			{
				spIStream2 = pvObject;
				spIStream2->AddRef();
			}
			else 
			{
				spIMimeMessage = pvObject;
				if (FAILED(spIMimeMessage->GetMessageSource(&spIStream2,NULL)))
					break;
			}
			
			// HrCopyStream(IStream* source, IStream* destionation, DWORD dwFlags);
			if (FAILED(HrCopyStream(spIStream2,spIStream,0)))
				break;
				
			if (FAILED(spIStream->Commit(0)))
				break;
				
			if (FAILED(CommitStream(0,0,dwMsgFlags,spIStream,MessageID,spIMimeMessage)))
				break;
			
			if (pdwMessageId)
				*pdwMessageId = MessageID;
				
			spIStream->Release();	
			
		break;}
		
		CommitStream(0,1,0,spIStream,MESSAGEID_INVALID,0);
		
	}
	
}
*/
;

//////////////////////////////////////////////////////////////////////////
// pseudocode
// HRESULT CMessageFolder::SaveMessage(MESSAGEID* pMessageId,DWORD dwflags,DWORD ARF,
//		IStream* pIStream,IMimeMessage* pIMimeMessage ,IStoreCallback* istrclb)
;	
/*
{
	CByteStream bstream(0,0);
	tagMESSAGEINFO msgINFO = {0};
	IStream* IStream_msgsource = 0;
	
	if (!pIMimeMessage)
		return E_INVALIDARG;
		
	if (!pMessageId && !(dwflags & 1))
		return E_INVALIDARG;
	
	for (;;) {	
		
		//_GetMsgInfoFromMessage(IMimeMessage *,tagMESSAGEINFO *)
		if (FAILED(_GetMsgInfoFromMessage(pIMimeMessage, &msgINFO)))
			break;
			
		if (dwflags & 1) // создаём принципиально новое письмо
		{
			if (FAILED(IMessageStore_ptr_global->GenerateID(msgINFO.dwMessageId)))
				break;
				
			if (pMessageID)
				*pMessageID = msgINFO.dwMessageId;
				
		} else // модифицируем старое письмо
		
			msgINFO.dwMessageId = *pMessageID;
		
		msgINFO.dwARF = ARF;
		
		if (!pIStream)
		{
			if (FAILED(pIMimeMessage->GetMessageSource(&IStream_msgsource,COMMIT_ONLYIFDIRTY)))
				break;
		} else
		{
			IStream_msgsource = pIStream;
			IStream_msgsource->AddRef();
		}
		
		//_SetMessageStream(tagMESSAGEINFO *,int,IStream *)
		if (FAILED(_SetMessageStream(&msgINFO,0,IStream_msgsource)))
			break;
			
		if (SUCCEEDED(pIMimeMessage->SaveOffsetTable(bstream,0))
			bstream.AcquireBytes(&msgINFO.StmOffsetTableSize,&msgINFO.StmOffsetTableBinary,1);
		
		if (FAILED(IMessageStore_ptr_global->InsertRecord(&msgINFO)))
			break;
			
		IMessageStore_ptr_global->DeleteStream(msgINFO.dbFileAddress);
	
	break;}
	
	_FreeMsgInfoData(&msgINFO);
	
	if (IStream_msgsource)
		IStream_msgsource->Release();
	
}
*/
;

//////////////////////////////////////////////////////////////////////////
// pseudocode
// long CMessageFolder::_SetMessageStream(tagMESSAGEINFO* msgINFO, int update,IStream* istr)
;	
/*
{
	iptrIStream spIStream;
	iptrIDatabaseStream spIdbStream;
	LPVOID fileaddress = 0;
	
	for (;;) {
	
		if (!msgINFO.cbMessage)
			if (FAILED(HrGetStreamSize(istr,&msgINFO.cbMessage)))
				break;
		
		if (FAILED(HrRewindStream(istr)))
			break;
			
		spIdbStream = istr;
		
		if (spIdbStream && (!spIdbStream->CompareDatabase(IMessageStore_ptr_global))
	
			spIdbStream->GetFileAddress(&fileaddress);
	
		else
		{
			if (FAILED(IMessageStore_ptr_global->CreateStream(&fileaddress)))
				break;
				
			if (FAILED(IMessageStore_ptr_global->OpenStream(0xC8,fileaddress,&spIStream)))
				break;
				
			if (FAILED(HrCopyStream(istr,spIStream,0)))
				break;
				
			if (FAILED(spIStream->Commit(0)))
				break;
		}
		
		// here we have correct fileaddress
		
		DWORD oldaddress = msgINFO.dbFileAddress;
		
		msgINFO.dbFileAddress = fileaddress;
		
		::GetSystemTimeAsFileTime(&msgINFO.ftSaved);
		
		msgINFO.dwARF |= 1;
		
		if (!update)
			fileaddress = 0;
		else if(SUCCEEDED(IMessageStore_ptr_global->UpdateRecord(&msgINFO)))
			fileaddress = 0;
			
		if (oldaddress)
			IMessageStore_ptr_global->DeleteStream(oldaddress);
		
	break;}
	
	if (fileaddress)
		IMessageStore_ptr_global->DeleteStream(fileaddress);
		
	return S_OK;
}
*/
;
//////////////////////////////////////////////////////////////////////////
// pseudocode
// HRESULT CStoreNamespace::RegisterNotification(DWORD dwReserved, HWND hwnd);
;	
/*
{
	if (dwReserved)
		return E_INVALIDARG;
		
	if (!hwnd)
		return E_INVALIDARG;
		
	if (!::IsWindow(hwnd))
		return E_INVALIDARG;
		
	Locker _lock(this); // EnterCriticalSection on creation; leaving on destruction.
	
	if (!m_initialized)
		return MSOEAPI_E_STORE_INITIALIZE;
		
	bool exit = false;
	for (int m = 0; m < m_num_notifies; ++ m)
		if (!m_array_notifies[m]) {
			m_array_notifies[m] = hwnd;
			exit = true; break;
	}
	if (!exit)
	{	
		HrRealloc(m_array_notifies, 4 * m_num_notifies);
		m_array_notifies[m_num_notifies++] = hwnd;
	}
	
	if (!m_notify_registered)
		if (SUCCEEDED(g_pStore->RegisterNotify(2,1,0,(IDatabaseNotify*)this)))
			m_notify_registered = true;
	
	return S_OK;
}
*/
;
//////////////////////////////////////////////////////////////////////////
// pseudocode
// HRESULT IStoreFolder::RegisterNotification(DWORD dwReserved,HWND hwnd);
;	
/*
{
	if (dwReserved)
		return E_INVALIDARG;
	
	if (!hwnd)
		return E_INVALIDARG;
		
	if (!::IsWindow(hwnd))
		return E_INVALIDARG;
		
	Locker _lock(this); // EnterCriticalSection on creation; leaving on destruction.
	
	if (m_notifyhwnd)
		return E_FAIL;
		
	HRESULT hr;
	hr = (IMessageFolder*)CFolderSync_ptr->RegisterNotify(0,1,0xF0001000,(IDatabaseNotify*)this);
	if (SUCCEEDED(hr))
		if (SUCCEEDED(g_pStore->RegisterNotify(2,1,0xF0002000,(IDatabaseNotify*)this))
			m_notifyhwnd = hwnd;
	
}
*/
;
//////////////////////////////////////////////////////////////////////////
// pseudocode
// HRESULT CFolderSync::RegisterNotify(ULONG u1,ULONG u2,ULONG u3,IDatabaseNotify * ntf);
;	
/*
{ return pCMessageFolder->RegisterNotify(u1,u2,u3,ntf);}
*/
;
//////////////////////////////////////////////////////////////////////////
// pseudocode
// HRESULT IDatabase::RegisterNotify(ULONG u1,ULONG u2,ULONG u3,IDatabaseNotify * ntf);
;	
/*
{
	if(ntf == NULL)
		return E_INVALIDARGS;
 
	if(u1 > 8)
		return E_INVALIDARGS;

	// only one subscription is allowed
	if(m_notifier != NULL)
		return E_INVALIDARGS;

  
		
  
}
*/
;
//////////////////////////////////////////////////////////////////////////
// pseudocode
// HRESULT IMessageFolder::RegisterNotify(ULONG u1,ULONG u2,ULONG u3,IDatabaseNotify * ntf);
;	
/*
{ return IMessageStore_ptr->RegisterNotify(u1,u2,u3,ntf); }
*/
;
//////////////////////////////////////////////////////////////////////////
// pseudocode
// HRESULT IMessageStore::RegisterNotify(ULONG u1,ULONG u2,ULONG u3,IDatabaseNotify * ntf);
;
/*
{ return IDatabase_ptr->RegisterNotify(u1,u2,u3,ntf); }
*/
;
//////////////////////////////////////////////////////////////////////////
// pseudocode
// long CStoreNamespace::OnTransaction(HTRANSACTION__ *a_trans, ULONG a_ulong, struct IDatabase *a_idb);
;	
/*
{
	tagFOLDERINFO finfonew={0}, finfoold={0};
	DWORD var18, ordinallist, transtype;
	
	Locker lock(this);
	for (;;)
	{
		if (!a_trans)
			break;
		
		if (FAILED(a_idb->GetTransaction(&a_trans,&transactiontype,&finfoold,&finfonew,&var18,&ordinallist)))
			break;
			
		if (finfoold.tagstate == 3)
		{
			FOLDERNOTIFYEX fldnotify={0};
			if (transtype == 0)
			{
				fldnotify.type = NEW_FOLDER;
				fldnotify.idFolderNew = finfoold.folderid;
			} 
			else if (transtype == 1)
			{
				fldnotify.idFolderOld = finfoold.folderid;
				fldnotify.idFolderNew = finfonew.folderid;

				if (!strcmp(finfonew.sz_foldername,finfoold.sz_foldername))
					fldnotify.type = RENAME_FOLDER;
				else if (finfonew.field_C != finfoold.field_C)
					fldnotify.type = MOVE_FOLDER;
				else if (finfonew.num_unread != finfoold.num_unread)
					fldnotify.type = UNREAD_CHANGED;
				else if (finfonew.dwflags != finfoold.dwflags)
					fldnotify.type = UPDATEFLAG_CHANGE;
			}
			else if (transtype == 2)
			{
				fldnotify.type = DELETE_FOLDER;
				fldnotify.idFolderNew = finfoold.folderid;
			}
			
			for (int i = 0; i < m_num_notifies; ++ i)
			{
				HWND hwnd = m_array_notifies[i];
				if (hwnd)
				{
					if (::IsWindow(hwnd))
					{
						newnotify = g_pMalloc->Alloc(12);
						if (!newnotify) return;
						memcpy(newnotify,fldnotify,12);
						::SendMessage(hwnd,WM_FOLDERNOTIFY,0,&newnotify);
					}
					
				}
			}
				
		}	
		
	break;}
	g_pStore->FreeRecord(&finfoold);
	g_pStore->FreeRecord(&finfonew);
}
*/
;
//////////////////////////////////////////////////////////////////////////
// pseudocode
// long CStoreFolder::OnTransaction(HTRANSACTION__ *a_trans, ULONG a_ulong, struct IDatabase *a_idb);
;	
/*
{
	tagMESSAGEINFO msginfo1 = {0}, msginfo2 = {0};
	tagFOLDERINFO fldinfo1 = {0}, fldinfo2 = {0};
	DWORD Msg, WPARAM wParam, LPARAM lParam = 0;
	
	Locker lock(this);
	for (;;)
	{
		if (a_ulong == 0xF0001000)
		{
			while (a_trans)
			{	
				DWORD transactiontype;
				if (FAILED(a_idb->GetTransaction(&a_trans,&transactiontype,&msginfo2,&msginfo1,&var10,&var2b8)))
					break;
			
				if (transactiontype == 0)
				{
					Msg =  WM_NEWMSGS;
					wParam = msginfo2.dwMessageId
				}
				else if (transactiontype == 1)
				{
					if (msginfo1.dwARF & 0x80 && !(msginfo2.dwARF & 0x80))
						Msg = WM_MARKEDASREAD;
						*wParam = msginfo1.dwMessageId;
						lParam = 1;
					} else if (msginfo2.dwARF & 0x80 && !(msginfo1.dwARF & 0x80))
					{
						Msg = WM_MARKEDASUNREAD;
						*wParam = msginfo1.dwMessageId;
						lParam = 1;
					}
				}
				else if (transactiontype == 2)
				{
					wParam = g_pMalloc->Alloc(4);
					*wParam = msginfo2.dwMessageId;
					Msg = WM_DELETEMSGS;
				}
			
				if (::IsWindow(m_notifywnd))
					::SendMessage(m_notifywnd,msg,wParam,lParam);
			}
		} else {
			while (a_trans)
			{
				DWORD transactiontype;
				if (FAILED(a_idb->GetTransaction(&a_trans,&transactiontype,&msginfo2,&msginfo1,&var10,&var2b8)))
					break;
			
				if (transactiontype == 2)
					::PostMessage(m_notifyhwnd,WM_DELETEFOLDER,fldinfo2.folderid,0);
			}
		}
			
	break;}
	
	g_pStore->FreeRecord(&fldinfo1);
	g_pStore->FreeRecord(&fldinfo2);
	CFolderSync_ptr->FreeRecord(msginfo1);
	CFolderSync_ptr->FreeRecord(msginfo2);
	
}
*/
;

//////////////////////////////////////////////////////////////////////////
// pseudocode
// long CStoreNamespace::CreateFolder(STOREFOLDERID dwParentId, LPCSTR pszName, DWORD dwReserved, LPSTOREFOLDERID pdwFolderId)
;	
/*
{
	tagFOLDERINFO finfo = {0};
	finfo.sz_foldername = pszName;
	finfo.parentfolderid = (dwParentId==0?1:dwParentId);
	finfo.dwFlags = 1;
	g_pStore->CreateFolder(0,var_7C,(IStoreCallback*)this);
}
*/
;

//////////////////////////////////////////////////////////////////////////
// pseudocode
// HRESULT CStoreNamespace::GetFolderProps(STOREFOLDERID dwFolderId,DWORD dwReserved,LPFOLDERPROPS pProps);
;	
/*
{
	if (dwFolderId == FOLDERID_INVALID) return E_INVALIDARG;
	if (dwReserved != 0) return E_INVALIDARG;
	if (!pProps) return E_INVALIDARG;
	
	Locker _lock(this);
	
	if (!m_initialized)
		return MSOEAPI_E_STORE_INITIALIZE;
		
	tagFOLDERINFO finfo = {0};
	if (!dwFolderID) ++dwFolderID;
	
	HRESULT hr = g_pStore->GetFolderInfo(dwFolderID,&finfo);
	
	if (FAILED(hr)) return hr;
	
	hr = FldInfoToFolderProps(&finfo,pProps);
	
	g_pStore->FreeRecord(&finfo);
	
	return hr;
}
*/
;

//////////////////////////////////////////////////////////////////////////
// pseudocode
// HRESULT FldInfoToFolderProps(tagFOLDERINFO *finfo,tagFOLDERPROPS *fprops)
;	
/*
{
	if (fprops.cbSize != 0x118) return INVALIDNARG;
	
	
	
	
}
*/
;

//////////////////////////////////////////////////////////////////////////
// pseudocode
// HRESULT IStoreFolder::MarkMessagesAsRead(BOOL fRead, DWORD dwReserved,LPMESSAGEIDLIST pMsgIdList);
;	
/*
{
	DWORD unread_80=0, read_80 = 0;
	
	if (!dwReserved) return E_INVALIDARG;
	
	if (!pMsgIdList->prgdwMsgId) return E_INVALIDARG;
	
	Locker _lock(this);
	
	if (fRead)
		read_80 = 0x80;
	else
		unread_80 = 0x80;
		
	IMessageFolder* msgf = m_myMessageFolder;
	
	return msgf->SetMessageFlags(pMsgIdList,&unread_80,0,(IStoreCallback*)this);
}
*/
;

//////////////////////////////////////////////////////////////////////////
// pseudocode
// HRESULT IStoreNamespace::CopyMoveMessages(IStoreFolder *pSource,IStoreFolder *pDest,
//						 LPMESSAGEIDLIST pMsgIdList, DWORD dwFlags, DWORD dwFlagsRemove,
//						 IProgressNotify *pProgress);
;	
/*
{
	if (!pSource) return E_INVALIDARG;
	if (!pDest) return E_INVALIDARG;
	if (!pMsgIdList) return E_INVALIDARG;
	Locker _lock(this);
	
	if (!m_initialized)
		return MSOEAPI_E_STORE_INITIALIZE;
		
	iptrCStoreFolder *p_stsource, *p_stdest;
	
	if (FAILED(pSource->QueryInterface(&_IID_CStoreFolder,(void**)&p_stsource)))
		return E_FAIL;
		
	if (FAILED(pDest->QueryInterface(&_IID_CStoreFolder,(void**)&p_stdest)))
		return E_FAIL;
		
	iptrIMessageFolder *p_imsource, *p_imdest;
	
	if (FAILED(p_stsource->GetMessageFolder(&p_imsource)))
		return E_FAIL;
	
	if (FAILED(p_stdest->GetMessageFolder(&p_imdest)))
		return E_FAIL;
		
	ADJUSTFLAGS adj = {0};
	adj.flARFReset = DwConvertMSGtoARF(dwFlagsRemove);
	
	return p_imsource->CopyMessages(p_imdest,dwFlags,pMsgIdList,&adj,0,IStoreCallback*(this));
	
}
*/
;

//////////////////////////////////////////////////////////////////////////
// pseudocode
// HRESULT IStoreFolder::GetMessageProps(MESSAGEID dwMessageId,DWORD dwFlags,LPMESSAGEPROPS pProps);
;	
/*
{
		
}
*/
;
//					   
////////////////////////////////////////////////////////////////////////////
//interface IMessageList : public IUnknown
//{
//	virtual HRESULT STDMETHODCALLTYPE CreateList(HWND__ *,IUnknown *,HWND__ * *);
//	virtual HRESULT STDMETHODCALLTYPE SetFolder(STOREFOLDERID&,IMessageServer *,int,tagFINDINFO *,IStoreCallback *);
//	virtual HRESULT STDMETHODCALLTYPE SetViewOptions(tagFOLDER_OPTIONS *);
//	virtual HRESULT STDMETHODCALLTYPE GetViewOptions(tagFOLDER_OPTIONS *);
//	virtual HRESULT STDMETHODCALLTYPE OnClose(void);
//	virtual HRESULT STDMETHODCALLTYPE GetRect(tagRECT *);
//	virtual HRESULT STDMETHODCALLTYPE SetRect(tagRECT);
//	virtual HRESULT STDMETHODCALLTYPE HasFocus(void);
//	virtual HRESULT STDMETHODCALLTYPE OnPopupMenu(HMENU__ *,ULONG);
//		// returns the list of selected messages. If the first pointer is not zero,
//		// it will contain the number of focused message. The size of array will be
//		// returned in the second pointer, the array itself - in the third (if they are
//		// exists. The result must be free using IMalloc::Free, using IMalloc,
//		// got using CoGetMalloc;
//	virtual HRESULT STDMETHODCALLTYPE GetSelected(ULONG* focused, ULONG* count,ULONG** table);
//		// returns the number of selected messages
//	virtual HRESULT STDMETHODCALLTYPE GetSelectedCount(ULONG *);
//	virtual HRESULT STDMETHODCALLTYPE GetMessageA(ULONG,int,int,IUnknown**);
//	virtual HRESULT STDMETHODCALLTYPE GetMessageInfo(ULONG,tagMESSAGEINFO * *);
//	virtual HRESULT STDMETHODCALLTYPE GetRowFolderId(ULONG,STOREFOLDERID*);
//	virtual HRESULT STDMETHODCALLTYPE MarkMessage(ULONG,tagMARK_TYPE);
//	virtual HRESULT STDMETHODCALLTYPE FreeMessageInfo(tagMESSAGEINFO *);
//	virtual HRESULT STDMETHODCALLTYPE MarkRead(int,ULONG);
//	virtual HRESULT STDMETHODCALLTYPE GetMessageTable(IMessageTable * *);
//	virtual HRESULT STDMETHODCALLTYPE GetListSelector(IListSelector * *);
//	virtual HRESULT STDMETHODCALLTYPE GetMessageCounts(ULONG *,ULONG *,ULONG *);
//	virtual HRESULT STDMETHODCALLTYPE GetMessageServer(IMessageServer * *);
//	virtual HRESULT STDMETHODCALLTYPE GetFocusedItemState(ULONG *);
//	virtual HRESULT STDMETHODCALLTYPE ProcessReceipt(IMimeMessage *);
//	virtual HRESULT STDMETHODCALLTYPE GetAdBarUrl(void);
//};



struct HLOCK__;
struct tagTABLEINDEX;
//struct tagTRANSACTIONTYPE;
struct tagRESULTLIST;
//struct tagFOLDERINFO;
struct HROWSET__;
struct HTRANSACTION__;
typedef unsigned short ushort;
typedef unsigned char uchar;

interface IDatabaseProgress;
interface IImnAccount;
interface IDatabase;
interface IMessageFolder;

interface IDatabaseNotify : public IUnknown
// IID_IDatabaseNotify = {5E8A5022-AC7C-11D1-9A16-00C04FA309D4};
{
	virtual HRESULT STDMETHODCALLTYPE OnTransaction(HTRANSACTION__ *,ULONG,IDatabase *) = 0;
};

// the interface will be returned from IMessageStore::EnumChildren (FOLDERID,1,void**);
// it realizes the enumerator for chindren folders related to the defined root folder.
interface IEnumerateFolders : public IUnknown
// IID_IEnumerateFolders = {8551C145-0C39-11D2-9A6A-00C04FA309D4}
{
	virtual HRESULT STDMETHODCALLTYPE Next(ULONG, LPVOID/*LPFOLDERINFO*/,ULONG *);
	virtual HRESULT STDMETHODCALLTYPE Skip(ULONG);
	virtual HRESULT STDMETHODCALLTYPE Reset(void);
	virtual HRESULT STDMETHODCALLTYPE Clone(IEnumerateFolders **);
	virtual HRESULT STDMETHODCALLTYPE Count(ULONG *);
};

// #define IEnumerateFolders* HENUMSTORE*;

interface IMessageStore : public IUnknown
// CLSID_MessageStore = {101A8FB9-F1B9-11d1-9A56-00C04FA309D4}
// IID_IMessageStore = {E883FC75-EC08-11D1-9A53-00C04FA309D4}
{
	virtual HRESULT STDMETHODCALLTYPE Lock(HLOCK__ * *);
	virtual HRESULT STDMETHODCALLTYPE Unlock(HLOCK__ * *);
	virtual HRESULT STDMETHODCALLTYPE InsertRecord(void *);
	virtual HRESULT STDMETHODCALLTYPE UpdateRecord(void *);
	virtual HRESULT STDMETHODCALLTYPE DeleteRecord(void *);
	virtual HRESULT STDMETHODCALLTYPE FindRecord(unsigned long,unsigned long,void *,unsigned long *);
	virtual HRESULT STDMETHODCALLTYPE GetRowOrdinal(unsigned long,void *,unsigned long *);
	virtual HRESULT STDMETHODCALLTYPE FreeRecord(void *);
	virtual HRESULT STDMETHODCALLTYPE GetUserData(void *,unsigned long);
	virtual HRESULT STDMETHODCALLTYPE SetUserData(void *,unsigned long);
	virtual HRESULT STDMETHODCALLTYPE GetRecordCount(unsigned long,unsigned long *);
	virtual HRESULT STDMETHODCALLTYPE GetIndexInfo(unsigned long,char * *,struct tagTABLEINDEX *);
	virtual HRESULT STDMETHODCALLTYPE ModifyIndex(unsigned long,char const *,struct tagTABLEINDEX const *);
	virtual HRESULT STDMETHODCALLTYPE DeleteIndex(unsigned long);
	virtual HRESULT STDMETHODCALLTYPE CreateRowset(unsigned long,unsigned long,struct HROWSET__ * *);
	virtual HRESULT STDMETHODCALLTYPE SeekRowset(struct HROWSET__ *,enum  tagSEEKROWSETTYPE,long,unsigned long *);
	virtual HRESULT STDMETHODCALLTYPE QueryRowset(struct HROWSET__ *,long,void * *,unsigned long *);
	virtual HRESULT STDMETHODCALLTYPE CloseRowset(struct HROWSET__ * *);
	virtual HRESULT STDMETHODCALLTYPE CreateStream(unsigned long *);
	virtual HRESULT STDMETHODCALLTYPE DeleteStream(unsigned long);
	virtual HRESULT STDMETHODCALLTYPE CopyStream(struct IDatabase *,unsigned long,unsigned long *);
	virtual HRESULT STDMETHODCALLTYPE OpenStream(enum  tagACCESSTYPE,unsigned long,struct IStream * *);
	virtual HRESULT STDMETHODCALLTYPE ChangeStreamLock(struct IStream *,enum  tagACCESSTYPE);
	// from CStoreNamespace is called as RegisterNotify(2,1,0,&me);
	virtual HRESULT STDMETHODCALLTYPE RegisterNotify(unsigned long,unsigned long,unsigned long,IDatabaseNotify *);
	virtual HRESULT STDMETHODCALLTYPE DispatchNotify(struct IDatabaseNotify *);
	virtual HRESULT STDMETHODCALLTYPE SuspendNotify(struct IDatabaseNotify *);
	virtual HRESULT STDMETHODCALLTYPE ResumeNotify(struct IDatabaseNotify *);
	virtual HRESULT STDMETHODCALLTYPE UnregisterNotify(struct IDatabaseNotify *);
	virtual HRESULT STDMETHODCALLTYPE LockNotify(unsigned long,struct HLOCK__ * *);
	virtual HRESULT STDMETHODCALLTYPE UnlockNotify(struct HLOCK__ * *);
	virtual HRESULT STDMETHODCALLTYPE GetTransaction(struct HTRANSACTION__ * *,enum  tagTRANSACTIONTYPE *,void *,void *,unsigned long *,struct tagORDINALLIST *);
	virtual HRESULT STDMETHODCALLTYPE MoveFileA(unsigned short const *);
	virtual HRESULT STDMETHODCALLTYPE SetSize(unsigned long);
	virtual HRESULT STDMETHODCALLTYPE Repair(void);
	virtual HRESULT STDMETHODCALLTYPE Compact(struct IDatabaseProgress *,unsigned long);
	virtual HRESULT STDMETHODCALLTYPE HeapAllocate(unsigned long,unsigned long,void * *);
	virtual HRESULT STDMETHODCALLTYPE HeapFree(void *);
	virtual HRESULT STDMETHODCALLTYPE GenerateId(unsigned long *);
	virtual HRESULT STDMETHODCALLTYPE GetClientCount(unsigned long *);
	virtual HRESULT STDMETHODCALLTYPE GetFile(unsigned short * *);
	virtual HRESULT STDMETHODCALLTYPE GetSize(unsigned long *,unsigned long *,unsigned long *,unsigned long *);
	virtual HRESULT STDMETHODCALLTYPE Initialize(LPCSTR pszPath);
	virtual HRESULT STDMETHODCALLTYPE Validate(unsigned long);
	virtual HRESULT STDMETHODCALLTYPE GetDirectory(LPSTR lpString1,int iMaxLength);
	virtual HRESULT STDMETHODCALLTYPE Synchronize(FOLDERID__ *,unsigned long,struct IStoreCallback *);
	virtual HRESULT STDMETHODCALLTYPE FindServerId(char const *,FOLDERID__ * *);
	virtual HRESULT STDMETHODCALLTYPE CreateServer(IImnAccount *,ULONG,FOLDERID__ * *);
	virtual HRESULT STDMETHODCALLTYPE CreateFolder(ULONG,tagFOLDERINFO *,IStoreCallback *);
	virtual HRESULT STDMETHODCALLTYPE OpenSpecialFolder(FOLDERID__ *,IMessageServer *,uchar,IMessageFolder**);
	virtual HRESULT STDMETHODCALLTYPE OpenFolder(FOLDERID__ ,IMessageServer *,ULONG,IMessageFolder**);
	virtual HRESULT STDMETHODCALLTYPE MoveFolder(FOLDERID__ ,FOLDERID__ ,ULONG,IStoreCallback *);
	virtual HRESULT STDMETHODCALLTYPE RenameFolder(FOLDERID__ ,char const *,ULONG,IStoreCallback *);
	virtual HRESULT STDMETHODCALLTYPE DeleteFolder(FOLDERID__ ,ULONG,IStoreCallback *);
	virtual HRESULT STDMETHODCALLTYPE GetFolderInfo(FOLDERID__ ,tagFOLDERINFO *);
	virtual HRESULT STDMETHODCALLTYPE GetSpecialFolderInfo(FOLDERID__ ,uchar,tagFOLDERINFO *);
	virtual HRESULT STDMETHODCALLTYPE SubscribeToFolder(FOLDERID__ ,int,IStoreCallback *);
	virtual HRESULT STDMETHODCALLTYPE GetFolderCounts(FOLDERID__ *,IStoreCallback *);
	virtual HRESULT STDMETHODCALLTYPE UpdateFolderCounts(FOLDERID__ ,long,long,long,long);
	virtual HRESULT STDMETHODCALLTYPE EnumChildren(FOLDERID__ ,int,IEnumerateFolders **);
	virtual HRESULT STDMETHODCALLTYPE GetNewGroups(FOLDERID__ *,_SYSTEMTIME *,IStoreCallback *);
};
/*
.text:6033782C                 dd offset ?Lock@CMessageStore@@UAGJPAPAUHLOCK__@@@Z ; CMessageStore::Lock(HLOCK__ * *)
.text:60337830                 dd offset ?Unlock@CMessageStore@@UAGJPAPAUHLOCK__@@@Z ; CMessageStore::Unlock(HLOCK__ * *)
.text:60337834                 dd offset ?InsertRecord@CMessageStore@@UAGJPAX@Z ; CMessageStore::InsertRecord(void *)
.text:60337838                 dd offset ?UpdateRecord@CMessageStore@@UAGJPAX@Z ; CMessageStore::UpdateRecord(void *)
.text:6033783C                 dd offset ?DeleteRecord@CMessageStore@@UAGJPAX@Z ; CMessageStore::DeleteRecord(void *)
.text:60337840                 dd offset ?FindRecord@CMessageStore@@UAGJKKPAXPAK@Z ; CMessageStore::FindRecord(unsigned long,unsigned long,void *,unsigned long *)
.text:60337844                 dd offset ?GetRowOrdinal@CMessageStore@@UAGJKPAXPAK@Z ; CMessageStore::GetRowOrdinal(unsigned long,void *,unsigned long *)
.text:60337848                 dd offset ?FreeRecord@CMessageStore@@UAGJPAX@Z ; CMessageStore::FreeRecord(void *)
.text:6033784C                 dd offset ?GetUserData@CMessageStore@@UAGJPAXK@Z ; CMessageStore::GetUserData(void *,unsigned long)
.text:60337850                 dd offset ?SetUserData@CMessageStore@@UAGJPAXK@Z ; CMessageStore::SetUserData(void *,unsigned long)
.text:60337854                 dd offset ?GetRecordCount@CMessageStore@@UAGJKPAK@Z ; CMessageStore::GetRecordCount(unsigned long,unsigned long *)
.text:60337858                 dd offset ?GetIndexInfo@CMessageStore@@UAGJKPAPADPAUtagTABLEINDEX@@@Z ; CMessageStore::GetIndexInfo(unsigned long,char * *,tagTABLEINDEX *)
.text:6033785C                 dd offset ?ModifyIndex@CMessageStore@@UAGJKPBDPBUtagTABLEINDEX@@@Z ; CMessageStore::ModifyIndex(unsigned long,char const *,tagTABLEINDEX const *)
.text:60337860                 dd offset ?DeleteIndex@CMessageStore@@UAGJK@Z ; CMessageStore::DeleteIndex(unsigned long)
.text:60337864                 dd offset ?CreateRowset@CMessageStore@@UAGJKKPAPAUHROWSET__@@@Z ; CMessageStore::CreateRowset(unsigned long,unsigned long,HROWSET__ * *)
.text:60337868                 dd offset ?SeekRowset@CMessageStore@@UAGJPAUHROWSET__@@W4tagSEEKROWSETTYPE@@JPAK@Z ; CMessageStore::SeekRowset(HROWSET__ *,tagSEEKROWSETTYPE,long,unsigned long *)
.text:6033786C                 dd offset ?QueryRowset@CMessageStore@@UAGJPAUHROWSET__@@JPAPAXPAK@Z ; CMessageStore::QueryRowset(HROWSET__ *,long,void * *,unsigned long *)
.text:60337870                 dd offset ?CloseRowset@CMessageStore@@UAGJPAPAUHROWSET__@@@Z ; CMessageStore::CloseRowset(HROWSET__ * *)
.text:60337874                 dd offset ?CreateStream@CMessageStore@@UAGJPAK@Z ; CMessageStore::CreateStream(unsigned long *)
.text:60337878                 dd offset ?DeleteStream@CMessageStore@@UAGJK@Z ; CMessageStore::DeleteStream(unsigned long)
.text:6033787C                 dd offset ?CopyStream@CMessageStore@@UAGJPAUIDatabase@@KPAK@Z ; CMessageStore::CopyStream(IDatabase *,unsigned long,unsigned long *)
.text:60337880                 dd offset ?OpenStream@CMessageStore@@UAGJW4tagACCESSTYPE@@KPAPAUIStream@@@Z ; CMessageStore::OpenStream(tagACCESSTYPE,unsigned long,IStream * *)
.text:60337884                 dd offset ?ChangeStreamLock@CMessageStore@@UAGJPAUIStream@@W4tagACCESSTYPE@@@Z ; CMessageStore::ChangeStreamLock(IStream *,tagACCESSTYPE)
.text:60337888                 dd offset ?RegisterNotify@CMessageStore@@UAGJKKKPAUIDatabaseNotify@@@Z ; CMessageStore::RegisterNotify(unsigned long,unsigned long,unsigned long,IDatabaseNotify *)
.text:6033788C                 dd offset ?DispatchNotify@CMessageStore@@UAGJPAUIDatabaseNotify@@@Z ; CMessageStore::DispatchNotify(IDatabaseNotify *)
.text:60337890                 dd offset ?SuspendNotify@CMessageStore@@UAGJPAUIDatabaseNotify@@@Z ; CMessageStore::SuspendNotify(IDatabaseNotify *)
.text:60337894                 dd offset ?ResumeNotify@CMessageStore@@UAGJPAUIDatabaseNotify@@@Z ; CMessageStore::ResumeNotify(IDatabaseNotify *)
.text:60337898                 dd offset ?UnregisterNotify@CMessageStore@@UAGJPAUIDatabaseNotify@@@Z ; CMessageStore::UnregisterNotify(IDatabaseNotify *)
.text:6033789C                 dd offset ?LockNotify@CMessageStore@@UAGJKPAPAUHLOCK__@@@Z ; CMessageStore::LockNotify(unsigned long,HLOCK__ * *)
.text:603378A0                 dd offset ?UnlockNotify@CMessageStore@@UAGJPAPAUHLOCK__@@@Z ; CMessageStore::UnlockNotify(HLOCK__ * *)
.text:603378A4                 dd offset ?GetTransaction@CMessageStore@@UAGJPAPAUHTRANSACTION__@@PAW4tagTRANSACTIONTYPE@@PAX2PAKPAUtagORDINALLIST@@@Z ; CMessageStore::GetTransaction(HTRANSACTION__ * *,tagTRANSACTIONTYPE *,void *,void *,unsigned long *,tagORDINALLIST *)
.text:603378A8                 dd offset ?MoveFileA@CMessageStore@@UAGJPBG@Z ; CMessageStore::MoveFileA(ushort const *)
.text:603378AC                 dd offset ?SetSize@CMessageStore@@UAGJK@Z ; CMessageStore::SetSize(unsigned long)
.text:603378B0                 dd offset ?Repair@CMessageStore@@UAGJXZ ; CMessageStore::Repair(void)
.text:603378B4                 dd offset ?Compact@CMessageStore@@UAGJPAUIDatabaseProgress@@K@Z ; CMessageStore::Compact(IDatabaseProgress *,unsigned long)
.text:603378B8                 dd offset ?HeapAllocate@CMessageStore@@UAGJKKPAPAX@Z ; CMessageStore::HeapAllocate(unsigned long,unsigned long,void * *)
.text:603378BC                 dd offset ?HeapFree@CMessageStore@@UAGJPAX@Z ; CMessageStore::HeapFree(void *)
.text:603378C0                 dd offset ?GenerateId@CMessageStore@@UAGJPAK@Z ; CMessageStore::GenerateId(unsigned long *)
.text:603378C4                 dd offset ?GetClientCount@CMessageStore@@UAGJPAK@Z ; CMessageStore::GetClientCount(unsigned long *)
.text:603378C8                 dd offset ?GetFile@CMessageStore@@UAGJPAPAG@Z ; CMessageStore::GetFile(ushort * *)
.text:603378CC                 dd offset ?GetSize@CMessageStore@@UAGJPAK000@Z ; CMessageStore::GetSize(unsigned long *,unsigned long *,unsigned long *,unsigned long *)
.text:603378D0                 dd offset ?Initialize@CMessageStore@@UAGJPBD@Z ; CMessageStore::Initialize(char const *)
.text:603378D4                 dd offset ?Validate@CMessageStore@@UAGJK@Z ; CMessageStore::Validate(unsigned long)
.text:603378D8                 dd offset ?GetDirectory@CMessageStore@@UAGJPADK@Z ; CMessageStore::GetDirectory(char *,unsigned long)
.text:603378DC                 dd offset ?Synchronize@CMessageStore@@UAGJPAUFOLDERID__@@KPAUIStoreCallback@@@Z ; CMessageStore::Synchronize(FOLDERID__ *,unsigned long,IStoreCallback *)
.text:603378E0                 dd offset ?FindServerId@CMessageStore@@UAGJPBDPAPAUFOLDERID__@@@Z ; CMessageStore::FindServerId(char const *,FOLDERID__ * *)
.text:603378E4                 dd offset ?CreateServer@CMessageStore@@UAGJPAUIImnAccount@@KPAPAUFOLDERID__@@@Z ; CMessageStore::CreateServer(IImnAccount *,unsigned long,FOLDERID__ * *)
.text:603378E8                 dd offset ?CreateFolder@CMessageStore@@UAGJKPAUtagFOLDERINFO@@PAUIStoreCallback@@@Z ; CMessageStore::CreateFolder(unsigned long,tagFOLDERINFO *,IStoreCallback *)
.text:603378EC                 dd offset ?OpenSpecialFolder@CMessageStore@@UAGJPAUFOLDERID__@@PAUIMessageServer@@EPAPAUIMessageFolder@@@Z ; CMessageStore::OpenSpecialFolder(FOLDERID__ *,IMessageServer *,uchar,IMessageFolder * *)
.text:603378F0                 dd offset ?OpenFolder@CMessageStore@@UAGJPAUFOLDERID__@@PAUIMessageServer@@KPAPAUIMessageFolder@@@Z ; CMessageStore::OpenFolder(FOLDERID__ *,IMessageServer *,unsigned long,IMessageFolder * *)
.text:603378F4                 dd offset ?MoveFolder@CMessageStore@@UAGJPAUFOLDERID__@@0KPAUIStoreCallback@@@Z ; CMessageStore::MoveFolder(FOLDERID__ *,FOLDERID__ *,unsigned long,IStoreCallback *)
.text:603378F8                 dd offset ?RenameFolder@CMessageStore@@UAGJPAUFOLDERID__@@PBDKPAUIStoreCallback@@@Z ; CMessageStore::RenameFolder(FOLDERID__ *,char const *,unsigned long,IStoreCallback *)
.text:603378FC                 dd offset ?DeleteFolder@CMessageStore@@UAGJPAUFOLDERID__@@KPAUIStoreCallback@@@Z ; CMessageStore::DeleteFolder(FOLDERID__ *,unsigned long,IStoreCallback *)
.text:60337900                 dd offset ?GetFolderInfo@CMessageStore@@UAGJPAUFOLDERID__@@PAUtagFOLDERINFO@@@Z ; CMessageStore::GetFolderInfo(FOLDERID__ *,tagFOLDERINFO *)
.text:60337904                 dd offset ?GetSpecialFolderInfo@CMessageStore@@UAGJPAUFOLDERID__@@EPAUtagFOLDERINFO@@@Z ; CMessageStore::GetSpecialFolderInfo(FOLDERID__ *,uchar,tagFOLDERINFO *)
.text:60337908                 dd offset ?SubscribeToFolder@CMessageStore@@UAGJPAUFOLDERID__@@HPAUIStoreCallback@@@Z ; CMessageStore::SubscribeToFolder(FOLDERID__ *,int,IStoreCallback *)
.text:6033790C                 dd offset ?HrSetNoSecUICallback@CMimeEditDocHost@@UAGJKP6GJK@Z@Z ; CMimeEditDocHost::HrSetNoSecUICallback(unsigned long,long (*)(unsigned long))
.text:60337910                 dd offset ?UpdateFolderCounts@CMessageStore@@UAGJPAUFOLDERID__@@JJJJ@Z ; CMessageStore::UpdateFolderCounts(FOLDERID__ *,long,long,long,long)
.text:60337914                 dd offset ?EnumChildren@CMessageStore@@UAGJPAUFOLDERID__@@HPAPAUIEnumerateFolders@@@Z ; CMessageStore::EnumChildren(FOLDERID__ *,int,IEnumerateFolders * *)
.text:60337918                 dd offset ?GetAdvise@CAddrObj@@UAGJPAK0PAPAUIAdviseSink@@@Z ;
*/

interface IMessageStoreWMail : public IUnknown
// CLSID_MessageStore = {101A8FB9-F1B9-11d1-9A56-00C04FA309D4}
// IID_IMessageStore = {E883FC75-EC08-11D1-9A53-00C04FA309D4}
{
	virtual HRESULT STDMETHODCALLTYPE Lock(HLOCK__ * *);
	virtual HRESULT STDMETHODCALLTYPE Unlock(HLOCK__ * *);
	virtual HRESULT STDMETHODCALLTYPE InsertRecord(void *);
	virtual HRESULT STDMETHODCALLTYPE UpdateRecord(void *);
	virtual HRESULT STDMETHODCALLTYPE DeleteRecord(void *);
	virtual HRESULT STDMETHODCALLTYPE FindRecord(unsigned long,unsigned long,void *,unsigned long *);
	virtual HRESULT STDMETHODCALLTYPE GetRowOrdinal(unsigned long,void *,unsigned long *);
	virtual HRESULT STDMETHODCALLTYPE FreeRecord(void *);
	virtual HRESULT STDMETHODCALLTYPE GetUserData(void *,unsigned long);
	virtual HRESULT STDMETHODCALLTYPE SetUserData(void *,unsigned long);
	virtual HRESULT STDMETHODCALLTYPE GetRecordCount(unsigned long,unsigned long *);
	virtual HRESULT STDMETHODCALLTYPE GetIndexInfo(unsigned long,char * *,tagTABLEINDEX *);
	virtual HRESULT STDMETHODCALLTYPE ModifyIndex(unsigned long,char const *,tagTABLEINDEX const *);
	virtual HRESULT STDMETHODCALLTYPE DeleteIndex(unsigned long);
	virtual HRESULT STDMETHODCALLTYPE CreateRowset(unsigned long,unsigned long,HROWSET__ * *);
	virtual HRESULT STDMETHODCALLTYPE SeekRowset(HROWSET__ *,tagSEEKROWSETTYPE,long,unsigned long *);
	virtual HRESULT STDMETHODCALLTYPE QueryRowset(HROWSET__ *,long,void * *,unsigned long *);
	virtual HRESULT STDMETHODCALLTYPE CloseRowset(HROWSET__ * *);
	virtual HRESULT STDMETHODCALLTYPE CreateStream(unsigned long *);
	virtual HRESULT STDMETHODCALLTYPE DeleteStream(unsigned long);
	virtual HRESULT STDMETHODCALLTYPE CopyStream(IDatabase *,unsigned long,unsigned long *);
	virtual HRESULT STDMETHODCALLTYPE OpenStream(tagACCESSTYPE,unsigned long,IStream * *);
	virtual HRESULT STDMETHODCALLTYPE ChangeStreamLock(IStream *,tagACCESSTYPE);
	virtual HRESULT STDMETHODCALLTYPE RegisterNotify(unsigned long,unsigned long,unsigned long,IDatabaseNotify *);
	virtual HRESULT STDMETHODCALLTYPE DispatchNotify(IDatabaseNotify *);
	virtual HRESULT STDMETHODCALLTYPE SuspendNotify();
	virtual HRESULT STDMETHODCALLTYPE ResumeNotify(IDatabaseNotify *);
	virtual HRESULT STDMETHODCALLTYPE UnregisterNotify(IDatabaseNotify *);
	virtual HRESULT STDMETHODCALLTYPE LockNotify(unsigned long,HLOCK__ * *);
	virtual HRESULT STDMETHODCALLTYPE UnlockNotify(HLOCK__ * *);
	virtual HRESULT STDMETHODCALLTYPE GetTransaction(HTRANSACTION__ * *,tagTRANSACTIONTYPE *,void *,void *,unsigned long *,tagORDINALLIST *);
	virtual HRESULT STDMETHODCALLTYPE MoveFileA(ushort const *);
	virtual HRESULT STDMETHODCALLTYPE SetSize(unsigned long);
	virtual HRESULT STDMETHODCALLTYPE Repair(void);
	virtual HRESULT STDMETHODCALLTYPE Compact(IDatabaseProgress *,unsigned long);
	virtual HRESULT STDMETHODCALLTYPE HeapAllocate(unsigned long,unsigned long,void * *);
	virtual HRESULT STDMETHODCALLTYPE HeapFree(void *);
	virtual HRESULT STDMETHODCALLTYPE GenerateId(unsigned long *);
	virtual HRESULT STDMETHODCALLTYPE GetClientCount(unsigned long *);
	virtual HRESULT STDMETHODCALLTYPE GetFile(ushort * *);
	virtual HRESULT STDMETHODCALLTYPE GetSize(unsigned long *,unsigned long *,unsigned long *,unsigned long *);
	virtual HRESULT STDMETHODCALLTYPE sub_50EE5DB4();
	virtual HRESULT STDMETHODCALLTYPE sub_50EE5DDD();
	virtual HRESULT STDMETHODCALLTYPE sub_50EE5DFD();
	virtual HRESULT STDMETHODCALLTYPE sub_50EE5E20();
	virtual HRESULT STDMETHODCALLTYPE sub_50EE5E43();
	virtual HRESULT STDMETHODCALLTYPE sub_50EE5E60();
	virtual HRESULT STDMETHODCALLTYPE sub_50EE5E80();
	virtual HRESULT STDMETHODCALLTYPE sub_50EE5E9D();
	virtual HRESULT STDMETHODCALLTYPE sub_50EE5EC3();
	virtual HRESULT STDMETHODCALLTYPE sub_50EE5EE9();
	virtual HRESULT STDMETHODCALLTYPE sub_50EE5F06();
	virtual HRESULT STDMETHODCALLTYPE sub_50EE5F32();
	virtual HRESULT STDMETHODCALLTYPE sub_50EE5F58();
	virtual HRESULT STDMETHODCALLTYPE sub_50EE5F8A();
	virtual HRESULT STDMETHODCALLTYPE sub_50EE5FB0();
	virtual HRESULT STDMETHODCALLTYPE sub_50EE5FD3();
	virtual HRESULT STDMETHODCALLTYPE sub_50EE5FFC();
	virtual HRESULT STDMETHODCALLTYPE sub_50EE601C();
	virtual HRESULT STDMETHODCALLTYPE sub_50EE603C();
	virtual HRESULT STDMETHODCALLTYPE sub_50EE6062();
	virtual HRESULT STDMETHODCALLTYPE Initialize(char const *);
	virtual HRESULT STDMETHODCALLTYPE Validate(unsigned long);
	virtual HRESULT STDMETHODCALLTYPE GetDirectory(char *,unsigned long);
	virtual HRESULT STDMETHODCALLTYPE Synchronize();
	virtual HRESULT STDMETHODCALLTYPE FindServerId(char const *,FOLDERID__ * *);
	virtual HRESULT STDMETHODCALLTYPE CreateServer(IImnAccount *,unsigned long,FOLDERID__ * *);
	virtual HRESULT STDMETHODCALLTYPE CreateFolder(unsigned long,tagFOLDERINFOWMAIL *,IStoreCallback *);
	virtual HRESULT STDMETHODCALLTYPE OpenSpecialFolder();
	virtual HRESULT STDMETHODCALLTYPE OpenFolder(FOLDERID__ ,DWORD /*0*/, IMessageServer * /*NULL*/,ULONG/*0*/,IMessageFolder**);
	virtual HRESULT STDMETHODCALLTYPE MoveFolder();
	virtual HRESULT STDMETHODCALLTYPE RenameFolder();
	virtual HRESULT STDMETHODCALLTYPE DeleteFolder();
	virtual HRESULT STDMETHODCALLTYPE GetFolderInfo(FOLDERID__, long /*0*/, tagFOLDERINFOWMAIL *);
	virtual HRESULT STDMETHODCALLTYPE GetSpecialFolderInfo();
	virtual HRESULT STDMETHODCALLTYPE SubscribeToFolder();
	virtual HRESULT STDMETHODCALLTYPE sub_50F09E22();
	virtual HRESULT STDMETHODCALLTYPE UpdateFolderCounts();
	virtual HRESULT STDMETHODCALLTYPE EnumChildren(FOLDERID__ ,int /*0*/,int /*1*/, IEnumerateFolders **);
};


interface IMessageFolder : public IUnknown
// IID_IMessageFolder = {E883FC76-EC08-11D1-9A53-00C04FA309D4}

{
	virtual HRESULT STDMETHODCALLTYPE Lock(HLOCK__ * *);
	virtual HRESULT STDMETHODCALLTYPE Unlock(HLOCK__ * *);
	virtual HRESULT STDMETHODCALLTYPE InsertRecord(void *);
	virtual HRESULT STDMETHODCALLTYPE UpdateRecord(void *);
	virtual HRESULT STDMETHODCALLTYPE DeleteRecord(void *);
	virtual HRESULT STDMETHODCALLTYPE FindRecord(ULONG,ULONG,void *,ULONG *);
	virtual HRESULT STDMETHODCALLTYPE GetRowOrdinal(ULONG,void *,ULONG *);
	virtual HRESULT STDMETHODCALLTYPE FreeRecord(void *);
	virtual HRESULT STDMETHODCALLTYPE GetUserData(void *,ULONG);
	virtual HRESULT STDMETHODCALLTYPE SetUserData(void *,ULONG);
	virtual HRESULT STDMETHODCALLTYPE GetRecordCount(ULONG,ULONG *);
	virtual HRESULT STDMETHODCALLTYPE GetIndexInfo(ULONG,char * *,tagTABLEINDEX *);
	virtual HRESULT STDMETHODCALLTYPE ModifyIndex(ULONG,char const *,tagTABLEINDEX const *);
	virtual HRESULT STDMETHODCALLTYPE DeleteIndex(ULONG);
	virtual HRESULT STDMETHODCALLTYPE CreateRowset(ULONG,ULONG,HROWSET__ * *);
	virtual HRESULT STDMETHODCALLTYPE SeekRowset(HROWSET__ *,tagSEEKROWSETTYPE,long,ULONG *);
	virtual HRESULT STDMETHODCALLTYPE QueryRowset(HROWSET__ *,long,void * *,ULONG *);
	virtual HRESULT STDMETHODCALLTYPE CloseRowset(HROWSET__ * *);
	virtual HRESULT STDMETHODCALLTYPE CreateStream(ULONG *);
	virtual HRESULT STDMETHODCALLTYPE DeleteStream(ULONG);
	virtual HRESULT STDMETHODCALLTYPE CopyStream(IDatabase *,ULONG,ULONG *);
	virtual HRESULT STDMETHODCALLTYPE OpenStream(enum tagACCESSTYPE,ULONG,IStream * *);
	virtual HRESULT STDMETHODCALLTYPE ChangeStreamLock(IStream *, enum tagACCESSTYPE);
	virtual HRESULT STDMETHODCALLTYPE RegisterNotify(ULONG,ULONG,ULONG,IDatabaseNotify *);
	virtual HRESULT STDMETHODCALLTYPE DispatchNotify(IDatabaseNotify *);
	virtual HRESULT STDMETHODCALLTYPE SuspendNotify(IDatabaseNotify *);
	virtual HRESULT STDMETHODCALLTYPE ResumeNotify(IDatabaseNotify *);
	virtual HRESULT STDMETHODCALLTYPE UnregisterNotify(IDatabaseNotify *);
	virtual HRESULT STDMETHODCALLTYPE LockNotify(ULONG,HLOCK__ * *);
	virtual HRESULT STDMETHODCALLTYPE UnlockNotify(HLOCK__ * *);
	virtual HRESULT STDMETHODCALLTYPE GetTransaction(HTRANSACTION__ * *,tagTRANSACTIONTYPE *,void *,void *,ULONG *,tagORDINALLIST *);
	virtual HRESULT STDMETHODCALLTYPE MoveFileA(ushort const *);
	virtual HRESULT STDMETHODCALLTYPE SetSize(ULONG);
	virtual HRESULT STDMETHODCALLTYPE Repair(void);
	virtual HRESULT STDMETHODCALLTYPE Compact(IDatabaseProgress *,ULONG);
	virtual HRESULT STDMETHODCALLTYPE HeapAllocate(ULONG,ULONG,void * *);
	virtual HRESULT STDMETHODCALLTYPE HeapFree(void *);
	virtual HRESULT STDMETHODCALLTYPE GenerateId(ULONG *);
	virtual HRESULT STDMETHODCALLTYPE GetClientCount(ULONG *);
	virtual HRESULT STDMETHODCALLTYPE GetFile(ushort * *);
	virtual HRESULT STDMETHODCALLTYPE GetSize(ULONG *,ULONG *,ULONG *,ULONG *);
	virtual HRESULT STDMETHODCALLTYPE Initialize(IMessageStore *,IMessageServer *,ULONG,FOLDERID__ *);
	virtual HRESULT STDMETHODCALLTYPE SetOwner(IStoreCallback*);
	virtual HRESULT STDMETHODCALLTYPE Close(void);
	virtual HRESULT STDMETHODCALLTYPE GetFolderId(FOLDERID__ * *);
	virtual HRESULT STDMETHODCALLTYPE GetMessageFolderId(MESSAGEID__ *,FOLDERID__ * *);
	virtual HRESULT STDMETHODCALLTYPE Synchronize(ULONG,ULONG,IStoreCallback *);
	virtual HRESULT STDMETHODCALLTYPE OpenMessage(MESSAGEID__ ,ULONG,IMimeMessage * *,IStoreCallback *);
	virtual HRESULT STDMETHODCALLTYPE SaveMessage(MESSAGEID__ *,ULONG,ULONG,IStream *,IMimeMessage *,IStoreCallback *);
	virtual HRESULT STDMETHODCALLTYPE SetMessageStream(MESSAGEID__ *,IStream *);
	virtual HRESULT STDMETHODCALLTYPE SetMessageFlags(tagMESSAGEIDLIST *,tagADJUSTFLAGS *,tagRESULTLIST *,IStoreCallback *);
	virtual HRESULT STDMETHODCALLTYPE CopyMessages(IMessageFolder *,ULONG,tagMESSAGEIDLIST *,tagADJUSTFLAGS *,tagRESULTLIST *,IStoreCallback *);
	virtual HRESULT STDMETHODCALLTYPE DeleteMessages(ULONG,tagMESSAGEIDLIST *,tagRESULTLIST *,IStoreCallback *);
	virtual HRESULT STDMETHODCALLTYPE ResetFolderCounts(ULONG,ULONG,ULONG,ULONG);
	virtual HRESULT STDMETHODCALLTYPE IsWatched(char const *,char const *);
	virtual HRESULT STDMETHODCALLTYPE GetDatabase(IDatabase * *);
	virtual HRESULT STDMETHODCALLTYPE ConnectionAddRef(void);
	virtual HRESULT STDMETHODCALLTYPE ConnectionRelease(void);
	virtual HRESULT STDMETHODCALLTYPE GetAdBarUrl(IStoreCallback *);
};


//////////////////////////////////////////////////////////////////////////
//typedef iptr <IMessageList,&IID_IMessageList>		iptrIMessageList;
//typedef iptr <IStoreCallback,&IID_IStoreCallback>	iptrIStoreCallback;
//typedef iptr <IMimeMessage,&IID_IMimeMessage>		iptrIMimeMessage;
//typedef iptr <IStream,&IID_IStream>					iptrIStream;
//typedef iptr <IMessageTable,&IID_IMessageTable>		iptrIMessageTable;
//typedef iptr <IStoreNamespace,&IID_IStoreNamespace>	iptrIStoreNamespace;
//typedef iptr <IStoreFolder,&IID_IStoreFolder>		iptrIStoreFolder;
//typedef iptr <IMessageStore,&IID_IMessageStore>		iptrIMessageStore;
//typedef iptr <IEnumerateFolders,&IID_IEnumerateFolders> iptrIEnumerateFolders;
//typedef iptr <IMessageFolder,&IID_IMessageFolder>		iptrIMessageFolder;


// directdb.dll (CLSID {4A16043F-676D-11d2-994E-00C04FA309D4})
  
interface IDatabase : public IUnknown
//	_IID_CDatabase = {8CA77091-7B1C-11D2-995F-00C04FA309D4}
//	_IID_IDatabase = {7157F0AE-967B-11D1-9A08-00C04FA309D4}
{	
	  virtual HRESULT STDMETHODCALLTYPE Lock(HLOCK__ * *);
	  virtual HRESULT STDMETHODCALLTYPE Unlock(HLOCK__ * *);
	  virtual HRESULT STDMETHODCALLTYPE InsertRecord(void *);
	  virtual HRESULT STDMETHODCALLTYPE UpdateRecord(void *);
	  virtual HRESULT STDMETHODCALLTYPE DeleteRecord(void *);
	  virtual HRESULT STDMETHODCALLTYPE FindRecord(ULONG,ULONG,void *,ULONG *);
	  virtual HRESULT STDMETHODCALLTYPE GetRowOrdinal(ULONG,void *,ULONG *);
	  virtual HRESULT STDMETHODCALLTYPE FreeRecord(void *);
	  virtual HRESULT STDMETHODCALLTYPE GetUserData(void *,ULONG);
	  virtual HRESULT STDMETHODCALLTYPE SetUserData(void *,ULONG);
	  virtual HRESULT STDMETHODCALLTYPE GetRecordCount(ULONG,ULONG *);
	  virtual HRESULT STDMETHODCALLTYPE GetIndexInfo(ULONG,char * *,tagTABLEINDEX *);
	  virtual HRESULT STDMETHODCALLTYPE ModifyIndex(ULONG,char const *,tagTABLEINDEX const *);
	  virtual HRESULT STDMETHODCALLTYPE DeleteIndex(ULONG);
	  virtual HRESULT STDMETHODCALLTYPE CreateRowset(ULONG,ULONG,HROWSET__ * *);
	  virtual HRESULT STDMETHODCALLTYPE SeekRowset(HROWSET__ *,tagSEEKROWSETTYPE,long,ULONG *);
	  virtual HRESULT STDMETHODCALLTYPE QueryRowset(HROWSET__ *,long,void * *,ULONG *);
	  virtual HRESULT STDMETHODCALLTYPE CloseRowset(HROWSET__ * *);
	  virtual HRESULT STDMETHODCALLTYPE CreateStream(ULONG *);
	  virtual HRESULT STDMETHODCALLTYPE DeleteStream(ULONG);
	  virtual HRESULT STDMETHODCALLTYPE CopyStream(IDatabase *,ULONG,ULONG *);
	  virtual HRESULT STDMETHODCALLTYPE OpenStream(tagACCESSTYPE,ULONG,IStream * *);
	  virtual HRESULT STDMETHODCALLTYPE ChangeStreamLock(IStream *,tagACCESSTYPE);
	  virtual HRESULT STDMETHODCALLTYPE RegisterNotify(ULONG,ULONG,ULONG,IDatabaseNotify *);
	  virtual HRESULT STDMETHODCALLTYPE DispatchNotify(IDatabaseNotify *);
	  virtual HRESULT STDMETHODCALLTYPE SuspendNotify(IDatabaseNotify *);
	  virtual HRESULT STDMETHODCALLTYPE ResumeNotify(IDatabaseNotify *);
	  virtual HRESULT STDMETHODCALLTYPE UnregisterNotify(IDatabaseNotify *);
	  virtual HRESULT STDMETHODCALLTYPE LockNotify(ULONG,HLOCK__ * *);
	  virtual HRESULT STDMETHODCALLTYPE UnlockNotify(HLOCK__ * *);
	  virtual HRESULT STDMETHODCALLTYPE GetTransaction(HTRANSACTION__ * *,tagTRANSACTIONTYPE *,void *,void *,ULONG *,tagORDINALLIST *);
	  virtual HRESULT STDMETHODCALLTYPE MoveFileA(ushort const *);
	  virtual HRESULT STDMETHODCALLTYPE SetSize(ULONG);
	  virtual HRESULT STDMETHODCALLTYPE Repair(void);
	  virtual HRESULT STDMETHODCALLTYPE Compact(IDatabaseProgress *,ULONG);
	  virtual HRESULT STDMETHODCALLTYPE HeapAllocate(ULONG,ULONG,void * *);
	  virtual HRESULT STDMETHODCALLTYPE HeapFree(void *);
	  virtual HRESULT STDMETHODCALLTYPE GenerateId(ULONG *);
	  virtual HRESULT STDMETHODCALLTYPE GetClientCount(ULONG *);
	  virtual HRESULT STDMETHODCALLTYPE GetFile(ushort * *);
	  virtual HRESULT STDMETHODCALLTYPE GetSize(ULONG *,ULONG *,ULONG *,ULONG *);
};

/*

interface IMessageServer : public IUnknown
//	_IID_IMessageServer = {CFAD2438-EC54-11D1-9A54-00C04FA309D4}
{ 

	  virtual HRESULT STDMETHODCALLTYPE Initialize(IMessageStore *,FOLDERID__ *,IMessageFolder *,FOLDERID__ *);
	  virtual HRESULT STDMETHODCALLTYPE ResetFolder(IMessageFolder *,FOLDERID__ *);
	  virtual HRESULT STDMETHODCALLTYPE Close(unsigned long);
	  virtual HRESULT STDMETHODCALLTYPE SetIdleCallback(IStoreCallback *);
	  virtual HRESULT STDMETHODCALLTYPE SynchronizeFolder(unsigned long,unsigned long,IStoreCallback *);
	  virtual HRESULT STDMETHODCALLTYPE GetMessageA(MESSAGEID__ *,IStoreCallback *);
	  virtual HRESULT STDMETHODCALLTYPE PutMessage(FOLDERID__ *,unsigned long,_FILETIME *,IStream *,IStoreCallback *);
	  virtual HRESULT STDMETHODCALLTYPE CopyMessages(IMessageFolder *,unsigned long,tagMESSAGEIDLIST *,tagADJUSTFLAGS *,IStoreCallback *);
	  virtual HRESULT STDMETHODCALLTYPE DeleteMessages(unsigned long,tagMESSAGEIDLIST *,IStoreCallback *);
	  virtual HRESULT STDMETHODCALLTYPE SetMessageFlags(tagMESSAGEIDLIST *,tagADJUSTFLAGS *,unsigned long,IStoreCallback *);
	  virtual HRESULT STDMETHODCALLTYPE GetServerMessageFlags(unsigned long *);
	  virtual HRESULT STDMETHODCALLTYPE SynchronizeStore(FOLDERID__ *,unsigned long,IStoreCallback *);
	  virtual HRESULT STDMETHODCALLTYPE CreateFolder(FOLDERID__ *,uchar,char const *,unsigned long,IStoreCallback *);
	  virtual HRESULT STDMETHODCALLTYPE MoveFolder(FOLDERID__ *,FOLDERID__ *,IStoreCallback *);
	  virtual HRESULT STDMETHODCALLTYPE RenameFolder(FOLDERID__ *,char const *,IStoreCallback *);
	  virtual HRESULT STDMETHODCALLTYPE DeleteFolder(FOLDERID__ *,unsigned long,IStoreCallback *);
	  virtual HRESULT STDMETHODCALLTYPE SubscribeToFolder(FOLDERID__ *,int,IStoreCallback *);
	  virtual HRESULT STDMETHODCALLTYPE GetFolderCounts(FOLDERID__ *,IStoreCallback *);
	  virtual HRESULT STDMETHODCALLTYPE GetNewGroups(_SYSTEMTIME *,IStoreCallback *);
	  virtual HRESULT STDMETHODCALLTYPE OnLock(void);
	  virtual HRESULT STDMETHODCALLTYPE ConnectionRelease(void);
	  virtual HRESULT STDMETHODCALLTYPE GetWatchedInfo(FOLDERID__ *,IStoreCallback *);
	  virtual HRESULT STDMETHODCALLTYPE GetAdBarUrl(IStoreCallback *);
	  virtual HRESULT STDMETHODCALLTYPE GetMinPollingInterval(IStoreCallback *);
}
			
interface IDatabaseSession : public IUnknown
// _IID_IDatabaseSession = {4A160440-676D-11D2-994E-00C04FA309D4}
{								  
	virtual HRESULT STDMETHODCALLTYPE OpenDatabase(char const *,ULONG,tagTABLESCHEMA const *,IDatabaseExtension *,IDatabase * *);
	virtual HRESULT STDMETHODCALLTYPE OpenDatabaseW(ushort const *,ULONG,tagTABLESCHEMA const *,IDatabaseExtension *,IDatabase * *);
	virtual HRESULT STDMETHODCALLTYPE OpenQuery(IDatabase *,char const *,IDatabaseQuery * *);
};

interface IPropertybucket : IUnknown
// _IID_IPropertyBucket = {EC320F20-4B33-11D1-AA10-006097D474C4}
{
	virtual HRESULT STDMETHODCALLTYPE GetProperty(char const *,tagPROPVARIANT *,DWORD);
	virtual HRESULT STDMETHODCALLTYPE SetProperty(char const *,tagPROPVARIANT const *,DWORD);
}

interface IOptionbucket : IPropertybucket
// _IID_IOptionBucket	= {EC320F21-4B33-11D1-AA10-006097D474C4}
// _IID_IOptionBucketEx	= {4091C7B0-5557-11D1-AA13-006097D474C4}
{
	virtual HRESULT STDMETHODCALLTYPE ValidateProperty(DWORD,tagPROPVARIANT const *,DWORD);
	virtual HRESULT STDMETHODCALLTYPE GetPropertyDefault(DWORD,tagPROPVARIANT *,DWORD);
	virtual HRESULT STDMETHODCALLTYPE GetPropertyInfo(DWORD,tagPROPINFO *,DWORD);
	virtual HRESULT STDMETHODCALLTYPE Initialize(tagOPTBCKTINIT const *);
	virtual HRESULT STDMETHODCALLTYPE ISetProperty(HWND__ *,char const *,tagPROPVARIANT const *,DWORD);
	virtual HRESULT STDMETHODCALLTYPE SetNotification(IOptionBucketNotify *);
	virtual HRESULT STDMETHODCALLTYPE EnableNotification(int);
	virtual HRESULT STDMETHODCALLTYPE GetValue(char const *,char const *,DWORD *,uchar *,DWORD *);
	virtual HRESULT STDMETHODCALLTYPE SetValue(char const *,char const *,DWORD,uchar *,DWORD);
}

interface COEJunkRule : IUnknown
// _IID_IOERule = {}
// _IID_IOERuleAddrList = {}
{
	virtual HRESULT STDMETHODCALLTYPE Reset(void);
	virtual HRESULT STDMETHODCALLTYPE GetState(unsigned long *);
	virtual HRESULT STDMETHODCALLTYPE IdentityInformationChanged(unsigned long);
	virtual HRESULT STDMETHODCALLTYPE GetPropA(tagRULE_PROP,unsigned long,tagPROPVARIANT *);
	virtual HRESULT STDMETHODCALLTYPE SetPropA(tagRULE_PROP,unsigned long,tagPROPVARIANT *);
	virtual HRESULT STDMETHODCALLTYPE Evaluate(char const *,tagMESSAGEINFO *,IMessageFolder *,IMimePropertySet *,IMimeMessage *,unsigned long,tagACT_ITEM * *,unsigned long *);
	virtual HRESULT STDMETHODCALLTYPE LoadReg(char const *);
	virtual HRESULT STDMETHODCALLTYPE SaveReg(char const *,int);
	virtual HRESULT STDMETHODCALLTYPE Clone(IOERule * *);
}

interface IDatabaseStream : public IStream
//	_IID_CDatabaseStream = {80C42C87-63C1-11D2-9949-00C04FA309D4}
//	_IID_IDatabaseStream = {82EAD219-A6EC-11D1-9A11-00C04FA309D4}
{	
	virtual HRESULT STDMETHODCALLTYPE GetFileAddress(ULONG *);
	virtual HRESULT STDMETHODCALLTYPE CompareDatabase(IDatabase *);
};

*/

#endif // !defined(_OESTAFF_H__INCLUDED_)
