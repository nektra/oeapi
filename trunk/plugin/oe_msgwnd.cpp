/* $Id: oe_msgwnd.cpp,v 1.32 2009/01/27 19:29:58 ibejarano Exp $
 *
 * Author: Pablo Yabo (pablo.yabo@nektra.com)
 *
 * Copyright (c) 2004-2008 Nektra S.A., Buenos Aires, Argentina.
 * All rights reserved.
 *
 **/


#include <windows.h>
#include <commctrl.h>
#include <time.h>
#include <shlobj.h>
#include <ole2.h>
#include <objbase.h>
#include <oleacc.h>
#include <richedit.h>

#include <richole.h>
#include <ole2.h>

#include "oe_menu.h"
#include "oe_msgwnd.h"

#include "se_plugin.h"
#include "se_debug.h"

#include "oe_toolbar.h"
#include "oeapi_utils.h"

using namespace comet;

// create the global message window manager
OEPluginMsgWndMgr MsgWndMgr;
HINSTANCE hOleAcc = NULL;
LPFNOBJECTFROMLRESULT pfObjectFromLresult = NULL;
UINT HtmlMsg = ::RegisterWindowMessage( _T("WM_HTML_GETOBJECT") );
UINT SET_BODY_MSG = ::RegisterWindowMessage( _T("WM_SET_BODY") );

UINT UNLOCK_MSG = ::RegisterWindowMessage( _T("WM_UNLOCK_MSG") );
UINT WM_OEAPI_DESTROY = ::RegisterWindowMessage( _T("OEAPI_WM_DESTROY") );

#define TO_ADDRESS_CTRL 0x3e9
#define CC_ADDRESS_CTRL 0x3eb
#define BCC_ADDRESS_CTRL 0x402
#define SUBJECT_CTRL 0x3ec

#define WM_MSGWND_NOTIFICATION 39999

//static INT msgList[1024];
//static INT msgCount = 0;

// BEGIN DEBUG
//#include "oeapi_utils.h"
//
//WNDPROC oldProcSysListView = NULL;
//LRESULT CALLBACK SysListView32WndProc(HWND hWnd,
//									 UINT msg,
//									 WPARAM wParam,
//									 LPARAM lParam);
// END DEBUG

//extern BOOL g_sendDlgSyncblocked;
//BOOL g_MessageSent = FALSE;

//---------------------------------------------------------------------------------//
LRESULT CALLBACK MsgWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	WNDPROC oldProc;
	static int counter = 0;
	OEPluginMsgWnd *msgWnd;

//	for(int j=0; j<msgCount; j++) {
//		if(msgList[j] == msg)
//			break;
//	}
//	if(j==msgCount) {
//		msgList[msgCount++] = msg;
//	}

	// message windows can be deleted only from this thread so we don't have to lock the object
	msgWnd = MsgWndMgr.GetMsgWnd(hWnd, FALSE);

	// this shouldn't happen
	if(msgWnd == NULL) {
		debug_print(DEBUG_ERROR, _T("MsgWndProc: msgWnd = NULL\n"));
		return FALSE;
	}

	oldProc = msgWnd->GetOldWndProc();

	// this shouldn't happen
	if(oldProc == NULL) {
		debug_print(DEBUG_ERROR, _T("MsgWndProc: oldProc = NULL\n"));
		return FALSE;
	}

	switch(msg)
	{
		case WM_PARENTNOTIFY:
		{
			if (LOWORD(wParam) == WM_CREATE) {
				if(msgWnd->GetTimerId() == 0) {
					UINT timerId = (UINT)::SetTimer(hWnd, 1, 100, NULL);
					msgWnd->SetTimerId(timerId);
				}
			}

			break;
		}

		case WM_DESTROY:
		{
			//debug_print(DEBUG_TRACE, _T("MsgWndProc: Byebye.\n"));
			//g_MessageSent = FALSE;
			if(msgWnd->GetMessageSent()) {
				msgWnd->SetMessageSent(FALSE);
				LockSendWindow(FALSE);
			}

			// Message windows is closing, check if we have to send wm_oeapi_destroy
			if(GetProp(hWnd, _T("OEAPI_MsgWndDestroying")) != (HANDLE)TRUE)
			{
				SetProp(hWnd, _T("OEAPI_MsgWndDestroying"), (HANDLE)TRUE);

				// Send wm_oeapi_destroy

				CallWindowProc(MsgWndProc, hWnd, WM_OEAPI_DESTROY, NULL, NULL);
			}


			// if it's the msg wnd of the main window, remove it before the event is triggered
			// to prevent a GetMsgWnd before it's removed. If that occurs, the GetMsgWnd
			// locks the window and it's not destroyed but it's not working any more. This
			// generates a exception (???) or a dead lock.
//			if(msgWnd->IsMainWndMsgWnd()) {
//				MsgWndMgr.RemoveWindow(hWnd);
//			}
//
//			// call the creation callback if any
//			if(Plugin.msgWndCb) {
//				(*Plugin.msgWndCb)((INT) hWnd, 2);
//			}
//
//
//			if(!msgWnd->IsMainWndMsgWnd()) {
//				MsgWndMgr.RemoveWindow(hWnd);
//			}
//
//			(*Plugin.detachCb)(FALSE);

			break;
		}

		case WM_TIMER:
		{
			if(!msgWnd->Initialized()) {
				msgWnd->Initialize(hWnd);
				::KillTimer(hWnd, msgWnd->GetTimerId());
//				// BEGIN DEBUG
//				HWND hListView = FindWindowRecursive(hWnd, _T("SysListView32"));
//				if(hListView) {
//					oldProcSysListView = (WNDPROC) GetWindowLong(hListView, GWL_WNDPROC);
//					SetWindowLong(hListView, GWL_WNDPROC, (DWORD) SysListView32WndProc);
//				}
//				// END DEBUG
			}
			break;
		}

		case WM_COMMAND:
		{
			// -1 in lParam indicates that the message was generated by OEAPI and shouldn't
			// be intercepted.
			if(Plugin.msgWndSendButtonCb && lParam != -1) {
				if(LOWORD(wParam) == OE_SEND_TOOLBAR_BTN) {
					if(msgWnd->GetPendingSendEvent()) {
						return TRUE;
					}
					msgWnd->SetPendingSendEvent(TRUE);
					// clear flag
					msgWnd->SetSendCancelled(FALSE);

					// call the 'Send' button clicked callback if any
					(*Plugin.msgWndSendButtonCb)(hWnd, FALSE);

					// eat the button click, the callback owner must call 'SendMail' after
					// processing
					return TRUE;
				}
				else if(LOWORD(wParam) == OE_SENDLATER_MENUITEM_BTN)
				{
					if(msgWnd->GetPendingSendEvent()) {
						return TRUE;
					}
					msgWnd->SetPendingSendEvent(TRUE);
					// clear flag
					msgWnd->SetSendCancelled(FALSE);

					// call the 'Send' button clicked callback if any
					(*Plugin.msgWndSendButtonCb)(hWnd, TRUE);

					// eat the button click, the callback owner must call 'SendMail' after
					// processing
					return TRUE;
				}
			}
			else if(lParam == -1) {
				//lParam == 0; 
				if(LOWORD(wParam) == OE_SEND_TOOLBAR_BTN) {
					//g_sendDlgSyncblocked = TRUE;
					LockSendWindow(TRUE);
					//g_MessageSent = TRUE;
					msgWnd->SetMessageSent(TRUE);
				}
			}

			WORD id = LOWORD(wParam);

			OEPluginTopLevelWndMgr* wndMgr = msgWnd->GetTopLevelWndMgr();

			if(wndMgr) {
				OEPluginToolbarBtn* btn = wndMgr->GetButton(id, FALSE);
				if(btn) {
					// notify msg button
					btn->NotifyMsgButtonClick(hWnd, id);
				}
			}

			OEPluginMenuMgr* menuMgr = msgWnd->GetMenuMgr();
			if(menuMgr) {
				if(menuMgr->NotifyMenuItemClick(hWnd, id)) {
					return FALSE;
				}
			}
			break;
		}

		case WM_MENUSELECT:
		{
			msgWnd->SetLastMenuSelect(LOWORD(wParam));
			break;
		}

		case WM_INITMENU:
		{
			msgWnd->SetLastInitMenu((HMENU) wParam);
			break;
		}

		case WM_INITMENUPOPUP:
		{
			HMENU menu = (HMENU) wParam;

			LRESULT lResult;

			lResult = CallWindowProc(oldProc, hWnd, msg, wParam,
										lParam);

			OEPluginMenuMgr* menuMgr = msgWnd->GetMenuMgr();
			//LONG style = OEPluginMsgWnd::OE_MSG_INVALID;
			//OEPluginTopLevelWndMgr* mgr = msgWnd->GetTopLevelWndMgr();
			//if(mgr)
			//{
			//	style = mgr->GetWndStyle();
			//}
			if(menuMgr)
			{
				// if it's equal it's a menu. Otherwise, it's a menu item with sub items.
				// only insert items if it is a menu
				if(menu == msgWnd->GetLastInitMenu())
				{
					//if(style ==  OEPluginMsgWnd::OE_MSG_SEND_WND)
					menuMgr->InsertMenuItems(menu, msgWnd->GetLastMenuSelect());
				}
				menuMgr->EnableAllMenus(hWnd);
			}

			return lResult;
		}

		// This notification is triggered by OE under different circumstances.
		// We use that it is *NOT* triggered after a message was succesful sent.
		case WM_MSGWND_NOTIFICATION:
		{
			if(msgWnd->GetMessageSent()) { // && IsSendWindowLocked()) {
				// Sent was aborted
				//g_MessageSent = FALSE;
				msgWnd->SetMessageSent(FALSE);
				//g_sendDlgSyncblocked = FALSE;
				LockSendWindow(FALSE);
			}
		}
	}
	if(msg == SET_BODY_MSG) {
		LPCWSTR str = (LPCWSTR)wParam;

		// body can be set only from the GUI thread.
		msgWnd->SetBodyGUIThread(str, (BOOL) lParam);
		return TRUE;
	}
	else if(msg == WM_OEAPI_DESTROY) {
		SetProp(hWnd, _T("OEAPI_MsgWndDestroying"), (HANDLE)TRUE);


		LRESULT lResult = CommonWndProc(oldProc, hWnd, msg, wParam, lParam);

		if(msgWnd->IsMainWndMsgWnd()) {
			MsgWndMgr.RemoveWindow(hWnd);
		}

		if(Plugin.msgWndCb) {
			(*Plugin.msgWndCb)(hWnd, 2);
		}


		if(!msgWnd->IsMainWndMsgWnd()) {
			MsgWndMgr.RemoveWindow(hWnd);
		}

		(*Plugin.detachCb)(FALSE);

		return lResult;
	}

	return CommonWndProc(oldProc, hWnd, msg, wParam, lParam);
}

// BEGIN DEBUG
//static INT msgList[1024];
//static INT msgCount = 0;
//
////---------------------------------------------------------------------------------//
//LRESULT CALLBACK SysListView32WndProc(HWND hWnd,
//									 UINT msg,
//									 WPARAM wParam,
//									 LPARAM lParam)
//{
//	for(int j=0; j<msgCount; j++) {
//		if(msgList[j] == msg)
//			break;
//	}
//	if(j==msgCount) {
//		msgList[msgCount++] = msg;
//	}
//
//	switch(msg)
//	{
//		case LVM_GETITEMCOUNT:
//		{
//			int count = CallWindowProc(oldProcSysListView, hWnd, msg, wParam, lParam);
//
//			for(int i=0; i<count; i++) {
//				LVITEM lvItem;
//				char file[1024];
//
//				lvItem.mask = LVIF_TEXT | LVIF_PARAM;
//				lvItem.iItem = i;
//				lvItem.iSubItem = 0;
//				lvItem.pszText = file;
//				lvItem.cchTextMax = sizeof(file);
//				ListView_GetItem(hWnd, &lvItem);
//			}
//
//			return count;
//		}
//	}
//
//	return CallWindowProc(oldProcSysListView, hWnd, msg, wParam, lParam);
//}
// END DEBUG

/////////////////////////////////////////////////////////////////////////////////////
//---------------------------------------------------------------------------------//
OEPluginMsgWndMgr::OEPluginMsgWndMgr()
{
	lock_.Init();
}

//---------------------------------------------------------------------------------//
OEPluginMsgWndMgr::~OEPluginMsgWndMgr()
{
	Lock();

	for(OEPluginMsgWndList::iterator it=msgWndList_.begin(); it!=msgWndList_.end(); it++) {
		OEPluginMsgWnd *msgWnd = *it;
		delete msgWnd;
	}
	Unlock();

	lock_.Term();
}

//---------------------------------------------------------------------------------//
OEPluginMsgWnd *OEPluginMsgWndMgr::AddWindow(HWND hMsg, BOOL isPreviewMsgWnd)
{
	//debug_print(DEBUG_TRACE, _T("OEPluginMsgWndMgr::AddWindow: %08x, %d.\n"), hMsg, isPreviewMsgWnd);

	OEPluginMsgWnd *msgWnd;
	OEPluginTopLevelWndMgr *mgr;

	OEPluginMenuMgr *menuMgr;

	msgWnd = new OEPluginMsgWnd(hMsg);

	if(!isPreviewMsgWnd) {
		mgr = new OEPluginTopLevelWndMgr(OEPluginToolbarMgr::Get()->GetMsgWndMgr());
		msgWnd->SetTopLevelWndMgr(mgr);

		menuMgr = OEPluginMenuMgr::Get(hMsg)->CreateMsgWndMgr(hMsg, MsgWndStyles::OE_ALL_MSG_WND);
		msgWnd->SetMenuMgr(menuMgr);
	}

	Lock();
	msgWndList_.push_back(msgWnd);
	Unlock();

	return msgWnd;
}

//---------------------------------------------------------------------------------//
VOID OEPluginMsgWndMgr::RemoveWindow(HWND hMsg)
{
	//debug_print(DEBUG_TRACE, _T("OEPluginMsgWndMgr::RemoveWindow: Enter %08x\n"), hMsg);
	OEPluginMsgWnd *msgWnd = GetMsgWnd(hMsg, FALSE);

	if(msgWnd) {
		while(!TryLockMsgWnd(msgWnd))
		{
			//DoEvents();
			MSG msg;
			while(::PeekMessage(&msg, 0, 0, 0, PM_NOREMOVE) > 0) {
			   if(::GetMessage(&msg, 0, 0, 0)) {
				   ::DispatchMessage(&msg);
			   }
			}
			// Sleep()
		}
		msgWndList_.remove(msgWnd);
		delete msgWnd;
		Unlock();

		/* Lock();
		// lock it: if we remove before locking, it could happen that the delete cannot
		// lock and the object is no longer in the list and the window proc will not
		// be able to handle the events. So, if we lock before we are sure that the
		// message handler will work fine until we can delete the object.
		msgWnd->Lock(TRUE);
		msgWndList_.remove(msgWnd);
		Unlock();
		delete msgWnd;
		msgWnd->Lock(TRUE); */
	}
	//debug_print(DEBUG_TRACE, _T("OEPluginMsgWndMgr::RemoveWindow: Leave %08x\n"), hMsg);
}

//---------------------------------------------------------------------------------//
OEPluginMsgWnd *OEPluginMsgWndMgr::GetMsgWnd(HWND hMsg, BOOL lock)
{
	//debug_print(DEBUG_INFO, _T("OEPluginMsgWndMgr::GetMsgWnd: Enter %08x\n"), hMsg);
	OEPluginMsgWnd *ret = NULL;

	Lock();
	for(OEPluginMsgWndList::iterator it=msgWndList_.begin(); it!=msgWndList_.end(); it++) {
		OEPluginMsgWnd *msgWnd = *it;
		if(msgWnd->GetWindowHandle() == hMsg || hMsg == (HWND)(-1) && msgWnd->IsPreviewMsgWnd()) {
			ret = msgWnd;
			break;
		}
	}

	if(ret && lock) {
		ret->Lock();
	}
	Unlock();

	//debug_print(DEBUG_INFO, _T("OEPluginMsgWndMgr::GetMsgWnd: Leave %08x\n"), hMsg);
	return ret;
}

//---------------------------------------------------------------------------------//
OEPluginMsgWnd *OEPluginMsgWndMgr::GetMsgWndByIndex(UINT index, BOOL lock)
{
	OEPluginMsgWnd *ret = NULL;

	Lock();
	for(OEPluginMsgWndList::iterator it=msgWndList_.begin(); it!=msgWndList_.end(); it++) {
		OEPluginMsgWnd *msgWnd = *it;

		if(index-- == 0) {
			ret = msgWnd;
			break;
		}
	}

	if(ret && lock) {
		ret->Lock();
	}
	Unlock();

	return ret;
}

//---------------------------------------------------------------------------------//
OEPluginMsgWnd *OEPluginMsgWndMgr::GetCurrentMsgWnd(BOOL lock)
{
	return GetMsgWnd((HWND) -1, lock);
}

//---------------------------------------------------------------------------------//
int OEPluginMsgWndMgr::GetActiveMsgWndID()
{
	int ret = -1;
	HWND hWnd;

	Lock();
	hWnd = GetForegroundWindow();

	while(hWnd && ret == -1) {
		for(OEPluginMsgWndList::iterator it=msgWndList_.begin(); it!=msgWndList_.end(); it++) {
			OEPluginMsgWnd *msgWnd = *it;

			if(hWnd == msgWnd->GetTopLevelWindowHandle()) {
				ret = msgWnd->GetID();
				break;
			}
		}

		if(ret == -1) {
			hWnd = GetWindow(hWnd, GW_HWNDNEXT);
		}
	}

	Unlock();

	return ret;
}

//---------------------------------------------------------------------------------//
void OEPluginMsgWndMgr::Lock()
{
	lock_.Enter();
}

//---------------------------------------------------------------------------------//
void OEPluginMsgWndMgr::Unlock()
{
	lock_.Leave();
}

//-----------------------------------------------------------//
BOOL OEPluginMsgWndMgr::TryLock()
{
	return lock_.TryEnter();
}

//-----------------------------------------------------------//
BOOL OEPluginMsgWndMgr::TryLockMsgWnd(OEPluginMsgWnd* msgWnd)
{
	BOOL ret = FALSE;
	if(TryLock())
	{
		if(msgWnd->TryLock())
		{
			ret = TRUE;
		}
		else
		{
			Unlock();
		}
	}
	return ret;
}

//-----------------------------------------------------------//
void OEPluginMsgWndMgr::UnlockMsgWnd(OEPluginMsgWnd* msgWnd)
{
	UNREFERENCED_PARAMETER(msgWnd);
}

/////////////////////////////////////////////////////////////////////////////////////
//---------------------------------------------------------------------------------//
OEPluginMsgWnd::OEPluginMsgWnd(HWND hMsg)
{
	hWnd_ = hMsg;
	init_ = FALSE;
	timerId_ = 0;
	pHTMLDocument2_ = NULL;
	ieServer_ = NULL;
	//lockCount_ = 0;
	destroyed_ = FALSE;
	locking_ = 0;
	topLevelMgr_ = NULL;
	isPreviewMsgWnd_ = FALSE;

	menuMgr_ = NULL;
	lastMenuSelect_ = -1;
	lastInitMenu_ = NULL;

	emptyMsgWnd_ = FALSE;

	pendingSentEvent_ = FALSE;
	messageSent_ = FALSE;

	wndStyle_ = MsgWndStyles::OE_MSG_INVALID;

	oldProc_ = (WNDPROC) GetWindowLongPtr(hMsg, GWLP_WNDPROC);
	SetWindowLongPtr(hMsg, GWLP_WNDPROC, (LONG_PTR)MsgWndProc);

	lock_.Init();
}

//---------------------------------------------------------------------------------//
OEPluginMsgWnd::~OEPluginMsgWnd()
{
	Lock();

	if(pHTMLDocument2_) {
		pHTMLDocument2_->Release();
		pHTMLDocument2_ = NULL;
	}

	if(topLevelMgr_) {
		delete topLevelMgr_;
		topLevelMgr_ = NULL;
	}
	if(menuMgr_) {
		delete menuMgr_;
		menuMgr_ = NULL;
	}
	if(oldProc_) {
		SetWindowLongPtr(hWnd_, GWLP_WNDPROC, (LONG_PTR)oldProc_);
		oldProc_ = NULL;
	}

	Unlock();

	destroyed_ = TRUE;

	// wait that the threads that are trying to lock exit.
	while(locking_) {
		Sleep(100);
	}

	lock_.Term();
}

//---------------------------------------------------------------------------------//
VOID OEPluginMsgWnd::Initialize(HWND hMainWnd)
{
	if(!init_ && !destroyed_) {
		// if the object has top level mgr, initialize it
		if(topLevelMgr_) {
			init_ = topLevelMgr_->Initialize(hMainWnd);
			wndStyle_ = topLevelMgr_->GetWndStyle();
		}
		else {
			init_ = TRUE;
			wndStyle_ = MsgWndStyles::OE_MSG_INVALID;
		}


		if(menuMgr_)
		{
			menuMgr_->Initialize(hMainWnd, wndStyle_);
		}

		if(GetHTMLDocument() && topLevelMgr_) {
			topLevelMgr_->SetKeyMsgWnd(ieServer_);
		}

		// call the creation callback if any
		if(Plugin.msgWndCb) {
			(*Plugin.msgWndCb)(hMainWnd, 1);
		}
	}
}

//---------------------------------------------------------------------------------//
HWND OEPluginMsgWnd::GetTopLevelWindowHandle()
{
	HWND hRet = GetWindowHandle();

	if(IsMainWndMsgWnd()) {
		HWND hAux = hRet;

		while(hAux) {
			hAux = GetParent(hAux);
			if(hAux) {
				hRet = hAux;
			}
		}
	}

	return hRet;
}

//---------------------------------------------------------------------------------//
HWND OEPluginMsgWnd::FindBodyCtrl()
{
	HWND ret = NULL;
	// Text only view, find richedit control
	HWND docHost = FindWindowEx(hWnd_, NULL, _T("ME_DocHost"), NULL);
	if(docHost == NULL) {
		debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::FindBodyCtrl: FindWindowEx ME_DocHost.\n"));
		return ret;
	}

	// 
	HWND mimeEditServer = FindWindowEx(docHost, NULL, _T("RichEdDoc Class"), NULL);
	if(mimeEditServer == NULL) {
		debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::FindBodyCtrl: FindWindowEx ##MimeEdit_Server.\n"));
		return ret;
	}

	HWND hRichEdit = FindWindowEx(mimeEditServer, NULL, _T("RichEdit20W"), NULL);
	//HWND hRichEdit = ::GetDlgItem(mimeEditServer, 0);
	if(hRichEdit == NULL) {
		// Try WinMail control
		hRichEdit = FindWindowEx(mimeEditServer, NULL, _T("RichEdit50W"), NULL);
		if(hRichEdit == NULL) {
			debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::FindBodyCtrl: FindWindowEx RichEditXXW failed.\n"));
			return ret;
		}
		ret = hRichEdit;
	}
	return ret;
}


//---------------------------------------------------------------------------------//
bstr_t OEPluginMsgWnd::GetBody()
{
	IHTMLElement *pBody;
	BSTR aux = NULL;
	bstr_t ret;
	HRESULT hr;

	if(destroyed_) {
		return ret;
	}

	if(!GetHTMLDocument()) {
		// Try to check if the view is in text only mode
		HWND hRichEdit = FindBodyCtrl();
		if(hRichEdit == NULL) {
			debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::GetBody: FindBodyCtrl failed.\n"));
			return ret;
		}

		std::basic_string<WCHAR> str;
		EDITSTREAM editStream;

		editStream.dwCookie = (DWORD_PTR)&str;
		editStream.dwError = 0;
		editStream.pfnCallback = (EDITSTREAMCALLBACK)ReadEditStreamCallback;

		::SendMessage(hRichEdit, EM_STREAMOUT, SF_UNICODE | SF_TEXTIZED, (LPARAM)&editStream);

		ret = str.c_str();
		return ret;
	}

	hr = pHTMLDocument2_->get_body(&pBody);
	if(FAILED(hr) || pBody == NULL) {
		debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::GetBody: Error get_body.\n"));
		return ret;
	}

	hr = pBody->get_innerHTML(&aux);
	if(FAILED(hr)) {
		debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::GetBody: Error get_innerHTML.\n"));
	}
	else {
		ret = aux;
		SysFreeString(aux);
	}

	pBody->Release();

	return ret;
}

//---------------------------------------------------------------------------------//
bstr_t OEPluginMsgWnd::GetBodyHTML()
{
	//IHTMLElement *pBody;
	//BSTR aux = NULL;
	bstr_t ret;
	//HRESULT hr;

	//if(destroyed_) {
	//	return ret;
	//}

	//if(!GetHTMLDocument()) {
	//	return ret;
	//}
	//hr = pHTMLDocument2_->get_body(&pBody);
	//if(FAILED(hr) || pBody == NULL) {
	//	debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::GetBodyLength: Error get_body.\n"));
	//	return ret;
	//}

	//hr = pBody->get_outerHTML(&aux);
	//if(FAILED(hr)) {
	//	debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::GetBodyLength: Error get_innerHTML.\n"));
	//}
	//else {
	//	ret = aux;
	//	SysFreeString(aux);
	//}

	//pBody->Release();

	return ret;
}
//---------------------------------------------------------------------------------//
int OEPluginMsgWnd::GetBodyLength()
{
	IHTMLElement *pBody;
	BSTR aux = NULL;
	int ret = 0;
	HRESULT hr;

	if(destroyed_) {
		return ret;
	}

	if(!GetHTMLDocument()) {
		return ret;
	}

	hr = pHTMLDocument2_->get_body(&pBody);
	if(FAILED(hr) || pBody == NULL) {
		debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::GetBodyLength: Error get_body.\n"));
		return ret;
	}

	hr = pBody->get_innerHTML(&aux);
	if(FAILED(hr)) {
		debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::GetBodyLength: Error get_innerHTML.\n"));
	}
	else {
		ret = SysStringLen(aux);
		SysFreeString(aux);
	}

	pBody->Release();

	return ret;
}

//---------------------------------------------------------------------------------//
BOOL OEPluginMsgWnd::SetBody(const bstr_t &body)
{
	if(destroyed_) {
		return FALSE;
	}

	return (BOOL)::SendMessage(hWnd_, SET_BODY_MSG, (WPARAM) body.w_str().c_str(), FALSE);
}

//---------------------------------------------------------------------------------//
BOOL OEPluginMsgWnd::SetBodyHTML(const bstr_t &body)
{
	if(destroyed_) {
		return FALSE;
	}

	return (BOOL)::SendMessage(hWnd_, SET_BODY_MSG, (WPARAM) body.w_str().c_str(), TRUE);
}

//---------------------------------------------------------------------------------//
bstr_t OEPluginMsgWnd::GetTo()
{
	return GetControlText(TO_ADDRESS_CTRL);
}

//---------------------------------------------------------------------------------//
BOOL OEPluginMsgWnd::SetTo(const bstr_t &address)
{
	return SetControlText(TO_ADDRESS_CTRL, address);
}

//---------------------------------------------------------------------------------//
bstr_t OEPluginMsgWnd::GetCc()
{
	return GetControlText(CC_ADDRESS_CTRL);
}

//---------------------------------------------------------------------------------//
BOOL OEPluginMsgWnd::SetCc(const bstr_t &address)
{
	return SetControlText(CC_ADDRESS_CTRL, address);
}

//---------------------------------------------------------------------------------//
bstr_t OEPluginMsgWnd::GetBcc()
{
	return GetControlText(BCC_ADDRESS_CTRL);
}

//---------------------------------------------------------------------------------//
BOOL OEPluginMsgWnd::SetBcc(const bstr_t &address)
{
	return SetControlText(BCC_ADDRESS_CTRL, address);
}

//---------------------------------------------------------------------------------//
bstr_t OEPluginMsgWnd::GetSubject()
{
	return GetControlText(SUBJECT_CTRL);
}

//---------------------------------------------------------------------------------//
BOOL OEPluginMsgWnd::SetSubject(const bstr_t &subject)
{
	return SetControlText(SUBJECT_CTRL, subject);
}

//---------------------------------------------------------------------------------//
bstr_t OEPluginMsgWnd::GetControlText(UINT ctrlId)
{
	bstr_t ret;
	HWND hWnd;

	if(destroyed_) {
		return ret;
	}

	hWnd = FindWindowEx(hWnd_, NULL, _T("OE_Envelope"), NULL);
	if(hWnd == NULL) {
		debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::GetControlText: Cannot get OE_Envelope.\n"));
		return ret;
	}

	hWnd = GetDlgItem(hWnd, ctrlId);
	if(hWnd == NULL) {
		debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::GetControlText: Cannot get control.\n"));
		return ret;
	}

	if(IsWMail()) {
		if(::IsWindowVisible(hWnd)) {
			EDITSTREAM editStream;
			std::basic_string<WCHAR> str;

			editStream.dwCookie = (DWORD_PTR)&str; //(DWORD_PTR)&ret;
			editStream.dwError = 0;
			editStream.pfnCallback = (EDITSTREAMCALLBACK)ReadEditStreamCallback;

			::SendMessage(hWnd, EM_STREAMOUT, SF_UNICODE | SF_TEXTIZED, (LPARAM)&editStream);
			ret = str.c_str();
		}
		return ret;
	}

	GETTEXTLENGTHEX tl;
	tl.codepage = 1200;
	tl.flags = ST_DEFAULT;

	INT bufLen;
	bufLen = (INT)SendMessage(hWnd, EM_GETTEXTLENGTHEX, (WPARAM) &tl, 0);
	if(bufLen) {
		IRichEditOle *richEdit = NULL;
		if(!SendMessage(hWnd, EM_GETOLEINTERFACE, 0, (LPARAM) &richEdit)) {
			debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::GetControlText: Error EM_GETOLEINTERFACE.\n"));
			return ret;
		}

		GETTEXTEX gt;
		gt.codepage = 1200;
		gt.flags = ST_DEFAULT;
		gt.cb = (bufLen+1) * sizeof(WCHAR);
		gt.lpDefaultChar = NULL;
		gt.lpUsedDefChar = NULL;

		WCHAR* buf = new WCHAR[bufLen+1]; //(WCHAR *) malloc((bufLen+1) * sizeof(WCHAR));
		if(buf == NULL) {
			debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::GetControlText: Error allocating buffer.\n"));
			richEdit->Release();
			return ret;
		}

		if(!SendMessage(hWnd, EM_GETTEXTEX, (WPARAM) &gt, (LPARAM) buf)) {
			delete [] buf; //free(buf);
			debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::GetControlText: Error EM_GETTEXTEX.\n"));
			richEdit->Release();
			return ret;
		}

		std::basic_string<WCHAR> str;
		int objCount = 0;

		for(int i=0;buf[i];i++) {
			if(buf[i] == '\xfc\xff') {
				REOBJECT ro;
				IDataObject *dataObj;

				ro.cbStruct = sizeof(REOBJECT);
				HRESULT hr = richEdit->GetObject(objCount++, &ro, REO_GETOBJ_POLEOBJ);
				if(hr == S_OK) {
					IOleObject *pOleObj = (IOleObject *) ro.poleobj;
					IEnumFORMATETC *pEnumFormatetc;
					FORMATETC etc;
					STGMEDIUM stg;

					hr = pOleObj->GetClipboardData(0, &dataObj);

					// the enumeration was necessary because the IDataObject::GetData
					// doesn't work if only the FORMATETC is filled asking for the
					// CF_UNICODETEXT. (Why???)
					if(hr == S_OK) {
						hr = dataObj->EnumFormatEtc(DATADIR_GET, &pEnumFormatetc);

						if(hr == S_OK) {
							while(pEnumFormatetc->Next(1, &etc, NULL) == S_OK) {
								if(etc.tymed & TYMED_HGLOBAL) {
									if(dataObj->GetData(&etc, &stg) == S_OK) {
										if(etc.cfFormat == CF_UNICODETEXT) {
											WCHAR *objData = (WCHAR *) ::GlobalLock(stg.hGlobal);

											if(objData) {
												//ret += objData;
												str += objData; 
											}

											::GlobalUnlock(stg.hGlobal);
										}

										ReleaseStgMedium(&stg);
									}
								}
							}

							pEnumFormatetc->Release();
						}

						dataObj->Release();
					}

					pOleObj->Release();
				}
			}
			else {
				str.append(1, buf[i]);
			}
		}

		delete [] buf; // free(buf);

		richEdit->Release();
		ret = str.c_str();
	}

	return ret;
}

//---------------------------------------------------------------------------------//
DWORD CALLBACK OEPluginMsgWnd::ReadEditStreamCallback(DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb)
{
	std::basic_string<WCHAR>* str = (std::basic_string<WCHAR>*)dwCookie;

	str->append((WCHAR*)pbBuff, cb/sizeof(WCHAR));
	*pcb = cb;

	return 0;
}

struct RichEditWriteData
{
	LPBYTE data;
	INT size;
	INT written;
};

//---------------------------------------------------------------------------------//
DWORD CALLBACK OEPluginMsgWnd::WriteEditStreamCallback(DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb)
{
	RichEditWriteData* data = (RichEditWriteData*)dwCookie;
	INT toWrite = min(cb, data->size - data->written);
	memcpy_s(pbBuff, cb, data->data + data->written, toWrite);
	data->written += toWrite;
	*pcb = toWrite;
	return 0;
}

//---------------------------------------------------------------------------------//
BOOL OEPluginMsgWnd::SetControlText(UINT ctrlId, const bstr_t &str)
{
	HWND hWnd;
	SETTEXTEX st;
	BOOL ret = FALSE;

	if(destroyed_) {
		return ret;
	}

	hWnd = FindWindowEx(hWnd_, NULL, _T("OE_Envelope"), NULL);
	if(hWnd == NULL) {
		debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::SetControlText: Cannot get OE_Envelope.\n"));
		return ret;
	}

	hWnd = GetDlgItem(hWnd, ctrlId);
	if(hWnd == NULL) {
		debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::SetControlText: Cannot get control.\n"));
		return ret;
	}

	st.codepage = 1200;
	st.flags = ST_DEFAULT;

	ret = (BOOL)::SendMessage(hWnd, EM_SETTEXTEX, (WPARAM) &st, (LPARAM) str.w_str().c_str());

	::SendMessage(hWnd, EM_SETMODIFY, (WPARAM) TRUE, 0);

	return ret;
}

//---------------------------------------------------------------------------------//
BOOL OEPluginMsgWnd::SetBodyGUIThread(LPCWSTR body, BOOL usePutInnerMethod)
{
	BOOL ret = FALSE;
	HRESULT hr;
	std::basic_string<WCHAR> newBody;

	if(!GetHTMLDocument()) {
		// Try to check if the view is in text only mode
		HWND hRichEdit = FindBodyCtrl();
		if(hRichEdit == NULL) {
			debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::SetBodyGUIThread: FindBodyCtrl failed.\n"));
			return FALSE;
		}

		EDITSTREAM editStream;

		RichEditWriteData data;
		data.data = (LPBYTE)body;
		data.written = 0;
		data.size = sizeof(WCHAR)*wcslen(body);
		editStream.dwCookie = (DWORD_PTR)&data;
		editStream.dwError = 0;
		editStream.pfnCallback = (EDITSTREAMCALLBACK)WriteEditStreamCallback;

		::SendMessage(hRichEdit, EM_STREAMIN, SF_UNICODE | SF_TEXT, (LPARAM)&editStream);

		return TRUE;
	}

	IHTMLElement *pBody;
	IHTMLElement *pParent;
	BSTR bstrSrc;

	if(!usePutInnerMethod) {
		hr = pHTMLDocument2_->get_body(&pBody);
		if(FAILED(hr)) {
			debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::SetBodyGUIThread: Cannot get body object.\n"));
			return FALSE;
		}

		// remove all the body
		hr = pBody->put_innerHTML(L"");
		if(FAILED(hr)) {
			debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::SetBodyGUIThread: Error put_innerHTML.\n"));
			pBody->Release();
			return FALSE;
		}

		hr = pBody->get_parentElement(&pParent);
		if(FAILED(hr)) {
			debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::SetBodyGUIThread: Error get_parentElement.\n"));
			pBody->Release();
			return FALSE;
		}

		hr = pParent->get_outerHTML(&bstrSrc);
		if(FAILED(hr)) {
			debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::SetBodyGUIThread: Error get_outerHTML.\n"));
			pBody->Release();
			pParent->Release();
			return FALSE;
		}

		// now, use the old source and replace only the body.
		// find the body tag and put the new body between the start and end tags of body
		BSTR where = wcsstr(bstrSrc, L"<BODY");
		if(where) {
			BSTR where2 = wcsstr(where, L">");

			if(where2) {
				where2[1] = 0;
				newBody = bstrSrc;
				newBody += body;
				where2 += 2;

				BSTR where3 = wcsstr(where2, L"</BODY>");
				if(where3) {
					newBody += where3;
				}
				else {
					debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::SetBodyGUIThread: Cannot find BODY end tag.\n"));
					newBody += L"</BODY></HTML>";
				}
			}
			else {
				debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::SetBodyGUIThread: Cannot find BODY start tag end.\n"));
				newBody = L"<HTML><BODY>";
				newBody += body;
				newBody += L"</BODY></HTML>";
			}
		}
		else {
			debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::SetBodyGUIThread: Cannot find BODY start tag.\n"));
			newBody = L"<HTML><BODY>";
			newBody += body;
			newBody += L"</BODY></HTML>";
		}

		SysFreeString(bstrSrc);

		pParent->Release();
		pBody->Release();

		// now, write the full html to the HTMLDocument2
		VARIANT *param;
		SAFEARRAY *sfArray;
		BSTR bstr = SysAllocString(newBody.c_str());

		// Creates a new one-dimensional array
		sfArray = SafeArrayCreateVector(VT_VARIANT, 0, 1);

		if(sfArray != NULL) {

			hr = SafeArrayAccessData(sfArray, (LPVOID*) &param);
			if(SUCCEEDED(hr)) {
				param->vt = VT_BSTR;
				param->bstrVal = bstr;

				hr = SafeArrayUnaccessData(sfArray);
				if(SUCCEEDED(hr)) {

					hr = pHTMLDocument2_->write(sfArray);
					if(SUCCEEDED(hr)) {
						hr = pHTMLDocument2_->close();
						if(SUCCEEDED(hr)) {
							ret = TRUE;
						}
					}
				}
				else {
					debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::SetBodyGUIThread: Error SafeArrayUnaccessData.\n"));
				}

			}
			else {
				debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::SetBodyGUIThread: Error SafeArrayAccessData.\n"));
			}

			SafeArrayDestroy(sfArray);
		}
		else {
			debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::SetBodyGUIThread: Error SafeArrayCreateVector.\n"));
			SysFreeString(bstr);
		}

//		SysFreeString(bstr);
	}
	else {
		hr = pHTMLDocument2_->get_body(&pBody);
		if(FAILED(hr)) {
			debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::SetBodyGUIThread: Cannot get body object.\n"));
			return FALSE;
		}

		bstrSrc  = SysAllocString(body);
		if(bstrSrc == NULL) {
			debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::SetBodyGUIThread: Error SysAllocString.\n"));
			pBody->Release();
			return FALSE;
		}

		hr = pBody->put_innerHTML(bstrSrc);
		if(FAILED(hr)) {
			debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::SetBodyGUIThread: Error put_innerHTML.\n"));
			SysFreeString(bstrSrc);
			pBody->Release();
			return FALSE;
		}

		SysFreeString(bstrSrc);
		pBody->Release();

		ret = TRUE;
	}

	return ret;
}

//---------------------------------------------------------------------------------//
VOID OEPluginMsgWnd::GetIHTMLDocument2(IDispatch** htmldoc)
{
	GetHTMLDocument();

	if(pHTMLDocument2_) {
		pHTMLDocument2_->QueryInterface(IID_IDispatch, (VOID**)htmldoc); 
	}
	else if(htmldoc != NULL) {
		*htmldoc = NULL;
	}
}

//---------------------------------------------------------------------------------//
BOOL OEPluginMsgWnd::GetHTMLDocument()
{
	HWND docHost;
	HWND mimeEditServer;
	HRESULT hr;
	BOOL ret = FALSE;

	if(destroyed_) {
		return FALSE;
	}

	if(!IsWindow(hWnd_)) {
		debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::GetHTMLDocument: Window not longer exist.\n"));
		return ret;
	}

	// I skip the optimization because it wasn't working fine for the initial OE window
	if(pHTMLDocument2_) {
		pHTMLDocument2_->Release();
		pHTMLDocument2_ = NULL;
	}

	// HACK: if the window doesn't have a topLevelMgr_ -> it is the msg preview of the
	// main window and it is initialized using ##MimeEdit_Server window, so skip it
	if(topLevelMgr_) {
		docHost = FindWindowEx(hWnd_, NULL, _T("ME_DocHost"), NULL);
		if(docHost == NULL) {
			debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::GetHTMLDocument: FindWindowEx ME_DocHost.\n"));
			return ret;
		}

		mimeEditServer = FindWindowEx(docHost, NULL, _T("##MimeEdit_Server"), NULL);
		if(mimeEditServer == NULL) {
			debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::GetHTMLDocument: FindWindowEx ##MimeEdit_Server.\n"));
			return ret;
		}
	}
	else {
		mimeEditServer = hWnd_;
	}

	ieServer_ = FindWindowEx(mimeEditServer, NULL, _T("Internet Explorer_Server"), NULL);
	if(ieServer_ == NULL) {
		debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::GetHTMLDocument: FindWindowEx Internet Explorer_Server.\n"));
		return ret;
	}

	LRESULT lResult = 0;
	::SendMessageTimeout(ieServer_, HtmlMsg, 0L, 0L, SMTO_ABORTIFHUNG, 3000, (DWORD_PTR*) &lResult);

	if(hOleAcc == NULL) {
		hOleAcc = ::LoadLibrary(_T("OLEACC.DLL"));

		if(hOleAcc == NULL) {
			debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::GetHTMLDocument: Cannot load OLEACC.DLL.\n"));
			return ret;
		}
		else {
			pfObjectFromLresult = (LPFNOBJECTFROMLRESULT)::GetProcAddress(hOleAcc, "ObjectFromLresult");
			if(pfObjectFromLresult == NULL) {
				debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::GetHTMLDocument: Cannot find ObjectFromLresult proc.\n"));
				return ret;
			}
		}
	}

	hr = (*pfObjectFromLresult)(lResult, IID_IHTMLDocument2, 0, (void**)&pHTMLDocument2_);
	if(FAILED(hr) || pHTMLDocument2_ == NULL) {
		debug_print(DEBUG_ERROR, _T("OEPluginMsgWnd::GetHTMLDocument: Cannot get IID_IHTMLDocument2 object.\n"));
		return ret;
	}

	return TRUE;
}

//---------------------------------------------------------------------------------//
BOOL OEPluginMsgWnd::Lock(BOOL processMsgs)
{
	MSG msg;
	BOOL ret = FALSE;

	locking_++;
	//dbgprint2("OEPluginMsgWnd::Lock: %08x %d\n", this, lockCount_);

	if(processMsgs) {
		// Lock if nobody has taken or process events.
		while(!destroyed_) {
			ret = lock_.TryEnter();

			if(ret) {
				break;
			}

			// Process messages to let the plugins call get/set functions
			// otherwise, the window will not process messages while it is locked
			if(::GetMessage(&msg, 0, 0, 0)) {
				::DispatchMessage(&msg);
			}
			else {
				PostMessage(msg.hwnd, msg.message, msg.wParam, msg.lParam);
			}

			Sleep(10);
		}
	}
	else {
		lock_.Enter();
		ret = TRUE;
	}

	locking_--;

	return ret;
}

//---------------------------------------------------------------------------------//
BOOL OEPluginMsgWnd::TryLock()
{
	BOOL ret = FALSE;

	ret = lock_.TryEnter();

	return ret;
}

//---------------------------------------------------------------------------------//
VOID OEPluginMsgWnd::Unlock()
{
	//dbgprint2("OEPluginMsgWnd::Unlock: %08x %d\n", this, lockCount_-1);
	lock_.Leave();

	// just to send a message and exit the GetMessage function
	PostMessage(hWnd_, UNLOCK_MSG, 0, 0);
}

